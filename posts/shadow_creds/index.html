<!doctype html><html lang=ru dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT | Ardent101</title><meta name=keywords content="Active Directory,Kerberos,Pentest,Теория,PKINIT"><meta name=description content="В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.
Если вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.
Вводная теория PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации."><meta name=author content="Ardent101"><link rel=canonical href=https://ardent101.github.io/posts/shadow_creds/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6ed90c28450051e5bafcc0bf4bfe033ff2b04454909211dc9e97b8a50525621.css integrity="sha256-1u2QwoRQBR5br8wL9L/gM/8rBEVJCSEdyel7ilBSViE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ardent101.github.io/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ardent101.github.io/static/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ardent101.github.io/static/favicon-32x32.png><link rel=apple-touch-icon href=https://ardent101.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ardent101.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT"><meta property="og:description" content="В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.
Если вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.
Вводная теория PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации."><meta property="og:type" content="article"><meta property="og:url" content="https://ardent101.github.io/posts/shadow_creds/"><meta property="og:image" content="https://ardent101.github.io/posts/shadow_creds/images/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-12T08:31:03+00:00"><meta property="article:modified_time" content="2022-12-12T08:31:03+00:00"><meta property="og:site_name" content="Ardent101"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ardent101.github.io/posts/shadow_creds/images/logo.png"><meta name=twitter:title content="Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT"><meta name=twitter:description content="В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.
Если вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.
Вводная теория PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ardent101.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT","item":"https://ardent101.github.io/posts/shadow_creds/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT","name":"Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT","description":"В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.\nЕсли вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.\nВводная теория PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации.","keywords":["Active Directory","Kerberos","Pentest","Теория","PKINIT"],"articleBody":"В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.\nЕсли вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.\nВводная теория PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации.\nЗачем понадобилось это расширение? Какими преимуществами оно обладает?\n По-хорошему для грамотного ответа необходимо обладать специализированными знаниями в криптографии, а размышлять “на пальцах” о подобных вопросах неблагодарное занятие. Те кто ничего не знал вряд ли поймут, те кто знал сочтут за невежду. Тем не менее этот материал не является строгой научной статьей, поэтому попробую предоставить небольшую вводную для общего развития и лучшего понимания о чем идет речь.\n При оценке защищенности информационных ресурсов организации одним из наиболее типовых и классических недостатков является использование словарных или нестойких к атакам методом подбора паролей. Сам по себе протокол Kerberos никак не позволяет защититься от подобных атак (см. ранее про распыление). Безусловно в Active Directory есть возможность реализовать строгую парольную политику, кроме того можно осуществлять мониторинг журнала событий с целью выявления и пресечения указанных атак. В ряде случаев это работает, но как решить проблему “на корню”?\nНачнем очень издалека. Пароль - что это вообще такое? В ГОСТ Р 58833-2020 “Защита информации. Идентификация и аутентификация. Общие положения” есть следующее определение:\nПароль - конфиденциальная аутентификационная информация, обычно состоящая из строки знаков.\nКлючевое слово - “обычно”. Действительно в качестве пароля также могут выступать: аппаратные токены, отпечатки пальцев, сетчатка глаза, голос, да мало ли что еще. Более того пароль может включать в себя сразу несколько факторов, например смарт карта с пин кодом.\n Оффтоп: следует различать двухфакторною и двухэтапную аутентификацию, чуть более подробно простым языком об этом можно прочитать здесь.\n Пароли, “состоящие из строки знаков”, обладают рядом недостатков, а именно:\n пароли могут быть словарными пароли надо помнить пользователи могут непреднамеренно раскрыть свои пароли в ходе фишинговых атак, в почтовой переписке или в файле на общедоступном сетевом хранилище при захвате сервера атакующий зачастую может извлечь пароль пользователя и использовать его для атаки методом повторного воспроизведения  Расширение PKINIT помогает минимизировать приведенные выше проблемы в рамках Kerberos. PKINIT реализует поддержку протоколов с открытым ключом и в частности позволяет внедрить аутентификацию по сертификатам или двухфакторную аутентификацию. Таким образом PKINIT может гарантировать использование несловарных, стойких к атакам метода перебора паролей.\nДалее попробуем разобраться, что такое “открытый ключ”.\nКриптография с открытым ключом Для начала рассмотрим, в чем разница между симметричным и ассиметричныи шифрованием.\nПри симметричном шифровании для шифрования и расшифрования данных используется один и тот же ключ, то есть от клиента и сервера требуется наличие общего одинакового секрета. В частности, именно этот вид шифрования по умолчанию используется в Kerberos в ходе предварительной аутентификации.\nПри асимметричном шифровании используется пара математически связанных между собой ключей: открытый и закрытый. Закрытый хранится в тайне, в то время, как открытый является публичным. То, что было зашифровано на одном ключе, расшифровывается с использованием второго.\nДля лучшего понимания рассмотрим следующую бытовую аналогию:\n При симметричном шифровании сообщение передается в ящике, закрытом на обычный замок. Ключ от замка хранится как у отправителя, так и у получателя. Для шифрования отправителю требуется положить сообщение в ящик и запереть его на замок с использованием ключа. Получатель открывает замок с помощью того же самого ключа и извлекает сообщение.  \r\r\rОбщий принцип симметричного шифрования\r\r\r При асимметричном шифровании сообщение передается в ящике, закрытом на необычный замок. Особенность замка заключается в том, что для его закрытия ничего не требуется, замок достаточно только защелкнуть, а вот для открытия уже необходим ключ. Получатель создает много копий замка и раздает их всем желающим, а ключ хранит у себя в секрете. Каждый, кто хочет отправить сообщение, кладет его в ящик и закрывает его на защелкивающийся замок, открыть который может только получатель.  \r\r\rСхема передачи сессионного ключа с использованием ассиметричного шифрования\r\r\rСимметричное шифрование работает быстро, но его узким местом является управление ключами, в частности возникают трудности при передаче общего секретного ключа по открытым каналам связи. Это важно при установлении защищенного соединения, например в сети Интернет.\nКриптография с открытым (ассиметричным) ключом позволяет эффективно решить указанную проблему, но при этом работает медленнее. В итоге на практике используется сочетание двух видов шифрования.\nДля лучшего понимания рассмотрим искусственный, но отчасти приближенный к реальности пример. Представим себе сеть, где для каждого пользователя имеется свой сервер, на котором развернута почта и личный блог с контактной информацией.\nРассмотрим возможный процесс обмена сообщениями в указанной сети:\n\r\r\rОбщий принцип асимметричного шифрования\r\r\r Пользователь Алиса находит сайт пользователя Боб и в разделе с контактной информацией узнает открытый ключ Боба Алиса генерирует секретный сессионный ключ, зашифровывает его с использованием открытого ключа Боба и отправляет получившиеся зашифрованное сообщение Бобу Боб, получив сообщение, расшифровывает его с помощью своего закрытого ключа и получает сессионный ключ Боб отправляет Алисе сообщение, зашифрованное с использованием полученного сессионного ключа. Дальнейшее общение шифруется на установленном сессионном ключе.  Важно отметить, что указанный пример подвержен атаке “человек по середине”. Атакующий может навязать отправителю свой сервер, вместо сервера Боба, например с помощью ARP-spoofing. Подложный сервер может содержать копию сайта Боба, но уже с другим значением открытого ключа, секретный ключ к которому имеется у атакующего. В результате отправитель направит атакующему сообщение зашифрованное на подставном открытом ключе.\nВозникает вопрос, как Алиса может убедиться в том, что открытый ключ Боба действительно принадлежит Бобу? То есть требуется аутентификация открытых ключей. Таким образом мы подошли к следующей теме.\nЭлектронная цифровая подпись Криптография с открытым ключом работает и в другую сторону. То, что было зашифровано с использованием закрытого ключа, может быть расшифровано с помощью соответствующего открытого ключа.\nКакой в этом смысл? Допустим, что мы обладаем подлинным открытым ключом некого Боба и этот самый Боб хочет выступить с публичным сообщением от своего имени. Тогда:\n Боб пишет текст сообщения и зашифровывает его с использованием своего закрытого ключа Боб публикует у себя на сайте зашифрованное сообщение Любой желающий может расшифровать сообщение и прочитать его содержимое  Тот факт, что сообщение было успешно расшифровано, свидетельствует о том, что оно было написано владельцем закрытого ключа, то есть Бобом. Тем самым способом возможно “подписывать” информацию.\nИными словами цифровая подпись позволяет получателю сообщения убедиться в аутентичности источника информации, а также проверить, была ли информация изменена (искажена), пока находилась в пути. Таким образом, цифровая подпись является средством аутентификации и контроля целостности данных.\nНа практике шифровать само сообщение ресурсозатратно, поэтому зашифровывается хеш сообщения, полученный с использованием специальной криптографической хеш-функции. Всюду далее к исходному сообщению прикладывается указанный шифрованный хеш, который и называют подписью. Любой желающий убедиться в подлинности должен самостоятельно вычислить хеш от сообщения и сравнить его с результатом расшифрования подписи.\nЦентр сертификации Тем не менее проблема аутентификации открытых ключей пока остается нерешенной. Одним из решений является введение сертификации открытых ключей с помощью доверенной третьей стороны - центра сертификации. В этом случае перед публикацией своего открытого ключа пользователь должен обратиться в центр сертификации чтобы получить сертификат.\nСертификат открытого ключа может содержать множество полей, например:\n Имя пользователя Открытый ключ пользователя Срок действия сертификата Наименование центра сертификации  Но самым главным полем является цифровая подпись, представляющая собой хеш от всех полей сертификата, зашифрованный на закрытом ключе центра сертификации.\nРассмотрим пример процедуры обмена сообщениями при наличии центра сертификации:\n\r\r\rПример обмена сообщений с использованием сертифицированного открытого ключа\r\r\r Алиса генерирует пару открытый / закрытый ключ. Алиса аутентифицируется в центре сертификации и передает туда свои данные, в частности открытый ключ. Центр сертификации проверяет полученные данные и подписывает их с использованием своего закрытого ключа. В результате получается сертификат открытого ключа, который передается Алисе.   Шаги 1-3 считаются стандартными для всех пользователей сети. Можно считать, что при регистрации каждый пользователь получает сертификат своего открытого ключа и открытый ключ Центра сертификации. Таким образом у Боба также есть сертификат для своего открытого ключа и открытый ключ Центра сертификации.\n Желая отправить сообщение, Боб с сайта Алисы извлекает открытый ключ и соответствующий ему сертификат. С помощью открытого ключа Центра сертификации Боб проверяет подлинность полученного сертификата. Боб доверяет Центру сертификации, а успешная проверка цифровой подписи сертификата означает, что Центр сертификации в свою очередь проверил принадлежность открытого ключа Алисе. Поэтому Боб может быть уверен, что извлеченный с сайта открытый ключ действительно принадлежит Алисе. Боб шифрует сообщение с использованием открытого ключа Алисы и подписывает его с использованием своего закрытого ключа. Получившиеся данные передаются Алисе. Получив сообщение, Алиса расшифровывает его с помощью своего закрытого ключа. Кроме того, благодаря электронной подписи Алиса может убедиться, что сообщение было отправлено именно Бобом. Таким образом обеспечивается взаимная аутентификация пользователей.   Любопытно отметить, что в рассмотренной схеме Центр сертификации необходим только при регистрации пользователя. Все остальное время Центр сертификации может быть вообще отключен.\n Приведенный пример иллюстрирует общую идею, что за счет введения дополнительной доверенной сущности возможно решить проблему управления открытыми ключами. На практике разумеется все устроено несколько сложнее.\nВажно заметить, что с внедрением процедуры сертификации в домене появляется еще один доверительный центр.\n\r\r\rЦентры доверия с сертификацией и без\r\r\rPKINIT в Kerberos Active Directory Расширение PKINIT позволяет использовать криптографию с открытым ключом на этапе предварительной аутентификации Kerberos. В первой части уже был подробно рассмотрен этап предварительной аутентификации. Вкратце напомню, что в “традиционном” случае от клиента и сервера требовалось знание общего симметричного ключа.\nТеперь рассмотрим в первом приближении обмен сообщениями с использованием PKINIT:\n\r\r\rAS_REQ запрос с PKINIT\r\r\rКлиент отправляет серверу аутентификации текущую метку времени, подписанную своим закрытым ключом, а также сертификат предназначенный для проверки подлинности передаваемого открытого ключа. Сервер аутентификации проверяет при помощи открытого ключа центра сертификации проверяет подлинность полученного сертификата открытого ключа клиента. С использованием проверенного открытого ключа клиента сервер аутентификации проверяет подпись метки времени и сравнивает её значение с текущим.  \r\r\rAS_REP запрос с PKINIT\r\r\rСервер аутентификации отправляет ответ Клиенту. Клиент с использованием своего закрытого ключа расшифровывает одну из частей принятого ответа. В расшифрованной части клиент проверяет сертификат открытого ключа сервера аутентификации. При помощи полученного открытого ключа сервера аутентификации клиент проверяет подпись AS-REP ключа. С использованием AS-REP ключа Клиент расшифровывает сессионный ключ для общения с контроллером домена. Клиент получает TGT и сессионный ключ для KDC.  После передачи TGT и сессионного ключа остальные этапы Kerberos аутентификации производятся точно также, как в “традиционном” случае.\nДотошному читателю может быть не понятно, зачем использовать промежуточный симметричный ключ (см. шаг №3). Почему вместо указанного ключа сразу не передавать сессионный ключ? Насколько понимаю, дело в том, что симметричный ключ может вырабатываться разными методами, имеющие свои преимущества и недостатки. Так глубоко копать нет смысла, поэтому для примера мы рассмотрели один, наиболее распространенный метод. Кроме того необходимо понимать, что рассмотренный пример является упрощением и в реальности передаваемые сообщения содержат больше полей, в частности содержащие случайные метки и идентифицирующую информацию.\n Более подробно ознакомиться с устройством PKINIT можно в RFC 4556\n Физическое хранение закрытых ключей Остался незатронутым вопрос хранения пользователями своих закрытых ключей. Для этого могут использоваться различные специализированные внешние устройства (смарт-карты, токены и др.) или внутренние аппаратные модули (TPM). Подобные устройства обладают встроенными устойчивыми к взлому хранилищами данных, а также микросхемами позволяющими выполнять необходимые криптографические операции.\nЗакрытый ключ может быть импортирован на устройство или сгенерирован самим устройством самостоятельно. Для активации устройства с целью выполнения операций требующих знания закрытого ключа, как правило необходимо пройти дополнительную проверку, например ввести пин-код.\nТаким образом обеспечивается двухфакторная аутентификация. Первый фактор - (чем обладаю?) физическое устройство, второй фактор (что знаю?) - пин-код.\nДвухфакторная аутентификация в Kerberos обладает множеством преимуществ:\n Гарантируется использование псевдослучайных длинных паролей. Исключается возможность хранения пароля в незащищенном месте, например в записке на рабочем столе или в файле на общедоступной сетевой папке. Пароль нельзя случайно разболтать или отправить третьему лицу, таким образом минимизируются фишинговые атаки.  Тем не менее существует ряд мифов, которые стоит развенчать.\nМиф 1: Использование внешнего устройства при двухфакторной аутентификации позволяет безопасно осуществлять вход в домен с незащищенных рабочих станций, так как вся ключевая информация хранится на изолированном носителе.\n Это утверждение некорректно. Как минимум на указанном рабочем месте будет присутствовать активный в течении нескольких часов TGT, скорее всего позволяющий продлить срок действия до 7 суток.  Миф 2: При использование двухфакторной аутентификации по Kerberos исключается использование протокола NTLM.\n Это неправда. Двухфакторная аутентификация в Kerberos может осуществляться с применением протокола NTLM. Подробнее почему так и как это можно эксплуатировать рассмотрим дальше.  NTLM в PKINIT Представим, что организация внедрила в Active Directory аутентификацию с использованием смарт-карт по протоколу Kerberos, но как быть с ресурсами, которые поддерживают вход только по NTLM?\nДля того, чтобы лучше разобраться в этом вопросе рассмотрим процесс интерактивного входа пользователя на рабочую станцию по смарт-карте с использованием расширения PKINIT.\nПользователь вставляет смарт-карту в устройство для чтения и вводит пароль. Далее PA_PK_AS_REQ-сообщение отправляется также, как было рассмотрено ранее. Отличия начинаются на втором шаге. Сервер аутентификации возвращает TGT, содержащий в PAC NT-хеш пароля клиента, зашифрованный на AS-REP ключе. После получения PA_PK_AS_REP-сообщения клиент не может получить доступ к своему NT-хешу, так как не знает секрет KDC, с использованием которого зашифрован TGT.\n\r\r\rPA_PK_AS_REP при использовании смарт-карты\r\r\rДалее клиент отправляет контроллеру домена запрос на получение TGS билета для доступа к рабочей станции. Обратите внимание, что в качестве принципала сервиса указывается host/hostname.domain.\n\r\r\rTGS_REQ при использовании смарт-карты\r\r\rКонтроллер домена копирует PAC, извлеченный из TGT, в TGS билет и отправляет получившийся TGS билет клиенту. Теперь вспоминаем, что речь идет об интерактивном входе в систему, то есть “секрет хоста” считается известным значением в рамках рабочей станции.\nСистема предоставит доступ для клиента, но гораздо важнее, что система расшифрует NT-хеш клиента с помощью AS-REP ключа и поместит указанный NT-хеш в кэш LSA. В дальнейшем в случае если какой-либо сервис не сможет работать по протоколу Kerberos, система использует для аутентификации хранящийся в LSA NT-хеш.\n\r\r\rTGS_REP при использовании смарт-карты\r\r\rТаким образом внедрение смарт-карт не исключает применения протокола NTLM.\nДополнительно почитать об аутентификации по смарт-картам можно в следующих источниках:\n MS-PKCA - Раздел 4 Leave the Door 0pen – Abusing 5martcard Authentication with Anderson PAC - Eran Nachshon. “Weaknesses and Best Practices of Public Key Kerberos with Smart Cards” Brad Hill.  Key Trust Рассмотренный ранее пример аутентификации с помощью центров сертификации и смарт-карт представляет модель доверия на основе сертификатов. Исторически это одна из первых моделей, реализованных в Active Directory, но со временем были добавлены и другие модели. В частности Microsoft в ходе разработки Windows Hello внедрила в Windows Server 2016 новую модель доверия под названием Key Trust.\n Рассказ про Windows Hello заслуживает отдельного материала. Вкратце и грубо Windows Hello - технология позволяющая осуществлять двухфакторную аутентификацию, в том числе с использованием биометрии (отпечаток пальца, радужная оболочка глаза, распознавание лица), при помощи встроенных функций операционных систем семейства Windows. Работает указанная технология как для персональных компьютеров, так и в домене (Windows Hello for Business).\nБолее подробно ознакомиться с Windows Hello можно по следующим ссылкам:\n“Exploiting Windows Hello for Business”, BlackHat, 2019 год. Официальная документация Windows Hello\n В Key Trust контроллер домена для проверки подлинности ключа клиента использует не сертификат, а специальный атрибут msDS-KeyCredentialLink содержащий открытый ключ учетной записи указанного клиента. Если быть точнее, то атрибут msDS-KeyCredentialLink является многозначным, так как у учетной записи может быть несколько устройств с которых она осуществляет вход в систему. Такое возможно, например, если у пользователя две рабочих станции, и соответственно для хранения закрытых ключей используются разные модули TPM.\nПри рассмотрении Key Trust может возникнуть ошибочное ощущение, что необходимость в центре сертификации теперь отсутствует. На самом деле это не так. Дело в том, что клиенты должны быть способны проверить подлинность открытого ключа контроллера домена, а для этого все же требуется сертификат, а значит и центр сертификации.\nТаким образом в Key Trust клиенты проверяют подлинность контроллера домена по сертификату открытого ключа, а контроллер в свою очередь проверяет подлинность получаемых сообщений, пытаясь расшифровать их открытым ключом из атрибута учетной записи.\nПрактическая часть Как представленная выше информация может пригодиться при тестировании на проникновение?\nВо вступлении уже были анонсированы атаки Shadow Credentials и UnPAC the Hash, но есть и другие атаки. Теперь перейдем к детальному разбору возможных атак и тонкостей при их реализации.\nPassTheCertificate Условия для проведения атаки: наличие ключевой пары и соответствующего сертификата от учетной записи пользователя.\nРезультат успешной атаки: доступ к ресурсам домена с правами атакуемой учетной записи.\nНачнем с наиболее простой атаки PassTheCertificate (PtC). По сути PassTheCertificate не атака, а полезный кирпичик будущих атак, представляющий собой легитимное действие.\nДля начала рассмотрим в каких форматах могут храниться ключи с сертификатами. Как правило, сталкиваться придется с файлами в формате PEM или PFX.\nPEM - включает файлы со следующими расширениями:\n .pem - предназначен для хранения открытого ключа учетной записи и сертификата к нему .key - содержит закрытый ключ учетной записи  PFX - содержит открытый, закрытый ключи учетной записи и сертификат в одном файле, который зашифрован с использованием пароля.\nЧуть более подробно почитать о форматах файлов криптографических ключей можно здесь.\nПри наличие указанных файлов возможно осуществить аутентификацию и получить TGT к учетной записи для которой предназначались ключи.\nКоманды для выполнения атаки в Linux:\nДля работы с PKINIT в Linux существует набор скриптов PKINITtools за авторством Dirk-jan.\nДля аутентификации по сертификату воспользуемся утилитой gettgtpkinit.py\nАутентификация по сертификату в формате PFX:\ngettgtpkinit.py -cert-pfx \"PATH_TO_PFX_CERT\" -pfx-pass \"CERT_PASSWORD\" \"FQDN_DOMAIN/TARGET_SAMNAME\" \"TGT_CCACHE_FILE\" Аутентификация по сертификату в формате PFX, кодированном в Base64:\ngettgtpkinit.py -pfx-base64 $(cat \"PATH_TO_B64_PFX_CERT\") \"FQDN_DOMAIN/TARGET_SAMNAME\" \"TGT_CCACHE_FILE\" Аутентификация по сертификату в формате PEM:\ngettgtpkinit.py -cert-pem \"PATH_TO_PEM_CERT\" -key-pem \"PATH_TO_PEM_KEY\" \"FQDN_DOMAIN/TARGET_SAMNAME\" \"TGT_CCACHE_FILE\" Команды для выполнения атаки в Windows:\nRubeus поддерживает работу с PFX-сертификатами, кодированными в Base64:\nRubeus.exe asktgt /user:\"TARGET_SAMNAME\" /certificate:\"BASE64_CERTIFICATE\" /password:\"CERTIFICATE_PASSWORD\" /domain:\"FQDN_DOMAIN\" /dc:\"DOMAIN_CONTROLLER\" /show В Windows сконвертировать PEM в PFX возможно с помощью openssl:\nopenssl pkcs12 -in \"cert.pem\" -keyex -CSP \"Microsoft Enhanced Cryptographic Provider v1.0\" -export -out \"cert.pfx\" В продолжение PassTheCertificate логично использовать PassTheTicket (PassTheTicket), но есть и другие атаки которые будут рассмотрены далее.\nИсточник информации - thehacker.recipes\nUnPAC the Hash Условия для проведения атаки: наличие ключевой пары и соответствующего сертификата к учетной записи.\nРезультат успешной атаки: NT-хеш пароля учетной записи.\nTGT это хорошо, но NT-хеш еще лучше. Для того, чтобы разобраться в атаке UnPAC the Hash рассмотрим, как устроена аутентификация User-to-User (U2U) по протоколу Kerberos.\nUser-to-User аутентификация U2U-аутентификация изначально задумывалась, чтобы обычные пользователи на своих рабочих станциях могли предоставлять другим пользователям некоторые сервисы, например NFS или FTP.\nРабочая станция пользователя считается незащищенным объектом, поэтому использовать её для хранения долговременных секретов нецелесообразно. В этом случае в TGS-билете в качестве секрета сервиса применяется кратковременный сессионный “ключ пользователя для KDC”. Но ведь KDC не хранит сессионные ключи, а извлекает их из TGT. Тогда как же KDC зашифровывает TGS-билет?\nДля лучшего понимания происходящего пошагово разберем этапы U2U-аутентификация.\n\r\r\r1. Начало U2U аутентификации\r\r\r Алиса проходит аутентификацию к Сервису Боба и предъявляет TGS-билет, зашифрованный с использованием долговременного секрета Боба (например NT-хеша). Сервис Боба не способен расшифровать предъявляемый TGS-билет, так как указанный сервис работает на рабочей станции и не имеет доступа к долговременному ключу Боба. Поэтому в ответ Сервис Боба отправляет сообщение о том, что должен использоваться механизм U2U и прилагает TGT Боба.   Передавать TGT в открытом виде нормально, несмотря на то что весь сетевой трафик считается известным третье стороне. Более того именно так и делается в KRB_AS_REP. Сам по себе TGT Боба без знания сессионного ключа для KDC не представляет никакой ценности и не позволяет проводить атаку PassTheTicket.\n \r\r\r2. TGS_REQ при U2U аутентификации\r\r\rАлиса запрашивает у контроллера домена TGS-билет с использованием U2U-аутентификации, о чем свидетельствует специальный флаг. Кроме того, в качестве дополнительного билета Алиса прилагает TGT Боба. Контроллер домена в свою очередь извлекает из полученных TGT сессионные ключи Алисы и Боба.  \r\r\r3. TGS_REP при U2U аутентификации\r\r\rКонтроллер домена отправляет Алисе TGS-билет зашифрованный с использованием извлеченного на предыдущем шаге сессионного ключа Боба.  \r\r\r4. AP_REQ при U2U аутентификации\r\r\rТеперь Сервис Боба может расшифровать полученный TGS-билет и предоставить доступ для Алисы.   Использование кратковременного ключа в качестве секрета также не позволяет провести Kerberoasting в отношении простых пользователей.\n В итоге зачем были нужны непростые объяснения всех этих механизмов?\nОбъяснение атаки UnPAC the Hash Дело в том, что пользователь может осуществить PKINIT + U2U запрос на аутентификацию к самому себе и таким образом получить свой NT-хеш.\nДля начала представим, что Алиса уже получила TGT с использованием PKINIT, как это было рассмотрено ранее.\n\r\r\rU2U_TGS_REQ при аутентификации к \"самому себе\"\r\r\rАлиса обращается к KDC с запросом U2U-аутентификации к своему же сервису и предоставляет в качестве дополнительного билета свой TGT, полученный в результате PKINIT и при этом содержащий PAC со своим NT-хешем.\n\r\r\rU2U_TGS_REP при аутентификации к \"самому себе\"\r\r\rКонтроллер домена возвращает Алисе TGS-билет, зашифрованный с использованием сессионного ключа Алисы для KDC. Алиса расшифровывает TGS-билет при помощи своего сессионного ключа, а затем расшифровывает свой NT-хеш при помощи AS-REP ключа.\nТаким образом обладая ключевой парой и соответствующим сертификатом от учетной записи, возможно узнать NT-хеш пароля указанной учетной записи. На практике атака PassTheCert в связке с UnPAC the Hash активно используются для эксплуатации результатов других атак.\nКоманды для выполнения атаки в Linux:\nСначала запрашиваем TGT при помощи PKINIT:\ngettgtpkinit.py -cert-pfx \"PATH_TO_CERTIFICATE\" -pfx-pass \"CERTIFICATE_PASSWORD\" \"FQDN_DOMAIN/TARGET_SAMNAME\" \"TGT_CCACHE_FILE\" С использованием полученного TGT и AS-REP ключа (отобразится в консоли в результате выполнения gettgtpkinit) получаем NT-хеш:\nexport KRB5CCNAME=\"TGT_CCACHE_FILE\" getnthash.py -key 'AS-REP key' 'FQDN_DOMAIN'/'TARGET_SAMNAME' Команды для выполнения атаки в Windows:\nRubeus.exe asktgt /getcredentials /user:\"TARGET_SAMNAME\" /certificate:\"BASE64_CERTIFICATE\" /password:\"CERTIFICATE_PASSWORD\" /domain:\"FQDN_DOMAIN\" /dc:\"DOMAIN_CONTROLLER\" /show Источники информации:\n User to User Kerberos Authentication using GSS-API Kerberos F.A.Q. Workstation Services and Kerberos Authentication at Project Athena Hacker Recipes - UnPAC the Hash  Shadow Credentials Условия для проведения атаки:\n Хотя бы один контроллер домена функционирует под управлением ОС Windows Server 2016 или выше Функциональный уровень домена Active Directory - Windows Server 2016 Контроллер домена обладает сертификатом для своего открытого ключа Возможность осуществить запись в атрибут msDS-KeyCredentialLink целевой учетной записи  Результат успешной атаки: доступ к ресурсам домена с правами атакуемой учетной записи (NT-хеш).\nЕсли атакующий обладает правом на запись в атрибут msDS-KeyCredentialLink некоторой учетной записи, то тогда он может поступить следующим образом:\n Самостоятельно сгенерировать пару открытый-закрытый ключ Записать открытый ключ в атрибут msDS-KeyCredentialLink атакуемой учетной записи (см. ранее) Осуществить атаку Pass the Certificate Осуществить атаку UnPAC the Hash и получить NT-хеш пароля атакуемой учетной записи   Наличие права на запись в атрибут msDS-KeyCredentialLink является частным случаем наличия следующих прав: GenericAll, GenericWrite, WriteOwner, WriteDACL.\n Реализация атаки В 2022 году на конференции Phdays Шлюндин Павел представил доклад “Другой взгляд атакующего на ACL в AD” в котором среди прочего мимоходом рассматривается эксплуатация права записи в атрибут msDS-KeyCredentialLink.\nБолее того, автор выложил в открытый доступ тренировочный образ виртуальной машины со специально установленными уязвимыми настройками, а также инструмент ldap_shell, предназначенный для автоматизации эксплуатации атак на ACL.\nДля демонстрации атаки Shadow Credentials на практике воспользуемся предоставленной виртуальной машиной (redteam.bro/user:P@ssw0rd).\nВыявить право на запись в атрибут msDS-KeyCredentialLink или равноценное право возможно с помощью BloodHound. Отдельно возможность записи в атрибут msDS-KeyCredentialLink отображается с помощью ребра AddKeyCredentialLink, но мы рассмотрим более общий случай.\n\r\r\rЧасть цепочки атаки, построенной с использованием BH\r\r\rИз анализа видно, что пользователь User опосредованно обладает правом GenericWrite (позволяет осуществлять запись в атрибут msDS-KeyCredentialLink) в отношении User1. Для реализации атаки воспользуемся утилитой ldap_shell.\nДля начала выполним шаги, избавляющие от опосредованности и подводящие к интересующей нас атаке Shadow Credentials:\n\r\r\rНеобязательный этап\r\r\rТеперь непосредственно проведем атаку Shadow Credentials:\n\r\r\rЭксплуатация Shadow Credentials с помощью ldap_shell\r\r\rСуществуют и другие инструменты для реализации указанной атаки. Посмотреть больше примеров эксплуатации атаки Shadow Credentials можно в прохождениях машины Outdated на HackTheBox (пример).\nКоманды для выполнения атаки в Windows:\nОдним из первых инструментов, эксплуатирующих Shadow Credentials был Whisker:\nWhisker.exe add /target:\"TARGET_SAMNAME\" /domain:\"FQDN_DOMAIN\" /dc:\"DOMAIN_CONTROLLER\" /path:\"cert.pfx\" /password:\"pfx-password\" Команды для выполнения атаки в Linux:\nСо временем был создан клон Whisker на python - PyWhisker:\npywhisker.py -d \"FQDN_DOMAIN\" -u \"user1\" -p \"CERTIFICATE_PASSWORD\" --target \"TARGET_SAMNAME\" --action \"list\" \r\r\rПример реализации атаки Shadow Credentials от PTSwarm\r\r\rПреимущества Shadow Credentials Существуют другие способы эксплуатации Generic-прав. Проведем небольшое сравнение:\n в отличие от RBCD эксплуатация Shadow Credentials не требует создания новой машинной учетной записи, удалить которую возможно только при наличии прав уровня администратора домена в отличие от Целевого Kerberoasting эксплуатация Shadow Credentials занимает непродолжительное время и не зависит от сложности текущего пароля пользователя  Кроме того, эксплуатация Shadow Credentials имеет другие преимущества:\n Не требует перезаписи пароля к учетной записи, что иногда расценивается как отказ в обслуживании и не допускается при проведении тестирования на проникновение Позволяет закрепиться в домене, так как даже при смене пароля к скомпрометированной учетной записи атакующий сохраняет возможность аутентифицироваться по сгенерированной ключевой паре с помощью PKINIT. Атакующему не требуется наделять дополнительными правами доступа какой-либо из легитимных объектов домена, компрометация которого впоследствии может быть выявлена. Закрепление особенно актуально применительно к машинным учетным записям, потому что пароли машинных учетных записей обновляются каждый 30 дней. Кроме того машинные учетные записи могут самостоятельно осуществлять запись в свой атрибут msDS-KeyCredentialLink в случае если указанный атрибут пустой.   Пользовательские учетные записи не могут самостоятельно изменить свой атрибут msDS-KeyCredentialLink.\n Relay атака Эксплуатировать Shadow Credentials возможно в том числе в ходе Relay-атаки.\nЧто такое Relay атака и как её осуществлять, заслуживает отдельного материала, но для тех кто хоть немного в теме приведу пример с необходимыми аргументами командной строки:\nntlmrelayx.py -t ldap://dc-ip --shadow-credentials Источники:\nI’m bringing relaying back: A comprehensive guide on relaying anno 2022\nEnterprises Key Admin Во многих инструментах (BloodHound, Pingcastle), выполняющих анализ небезопасных настроек Active Directory, особое внимание уделяется членству пользователей домена в определенных группах, например: Backup Operators, Account Operators, Server Operators и др.\nЧуть подробнее об этом можно прочитать в следующих материалах:\n Poc’ing Beyond Domain Admin - Part 1 Beyond Domain Admins – Domain Controller \u0026 AD Administration  Дело в том, что члены указанных групп неявно обладают правами уровня администратора домена. По умолчанию приведенные группы не содержат никаких членов за некоторым исключением, но в реальности в них можно встретить нестандартные учетные записи.\nПрименительно к теме статьи в Active Directory существуют две встроенные группы “Key Admins” и “Enterprise Key Admins”. Члены указанных групп обладают правом на изменение атрибута ms-DS-Key-Credential-Link для объектов компьютер, что позволяет осуществлять атаку Shadow Credentials.\nВ BloodHound наличие пользователей в группе “Key Admins” можно проверить следующим запросом:\nmatch (u:User)-[:MemberOf]-(g:Group {name:\"KEY ADMINS@DOMAIN.LOCAL\"}) return u.name Заключение В настоящем материале были рассмотрены некоторые основные принципы работы расширения PKINIT и сертификатов в Active Directory. В дальнейшем были разобраны типовые техники атак с использованием рассмотренных принципов, а также приведены практические примеры и команды для реализации указанных атак.\nИспользуемые источники  “Shadow Credentials: Abusing Key Trust Account Mapping for Account Takeover” Книга “Kerberos: The Definitive Guide” за авторством Jason Garman Hacker Recipes Telegram канал “CyberSecrets”  ","wordCount":"4220","inLanguage":"ru","image":"https://ardent101.github.io/posts/shadow_creds/images/logo.png","datePublished":"2022-12-12T08:31:03Z","dateModified":"2022-12-12T08:31:03Z","author":{"@type":"Person","name":"Ardent101"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ardent101.github.io/posts/shadow_creds/"},"publisher":{"@type":"Organization","name":"Ardent101","logo":{"@type":"ImageObject","url":"https://ardent101.github.io/static/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ardent101.github.io/ accesskey=h title="Главная (Alt + H)"><img src=https://ardent101.github.io/apple-touch-icon.png alt=logo aria-label=logo height=35>Главная</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ardent101.github.io/archives/ title=Архив><span>Архив</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT</h1><div class=post-meta><span title="2022-12-12 08:31:03 +0000 +0000">декабря 12, 2022</span>&nbsp;·&nbsp;20 мин&nbsp;·&nbsp;Ardent101</div></header><figure class=entry-cover><img loading=lazy srcset="https://ardent101.github.io/posts/shadow_creds/images/logo_hu87a72e17709afdcf6c769a5cec04ba65_2863834_360x0_resize_box_3.png 360w ,https://ardent101.github.io/posts/shadow_creds/images/logo_hu87a72e17709afdcf6c769a5cec04ba65_2863834_480x0_resize_box_3.png 480w ,https://ardent101.github.io/posts/shadow_creds/images/logo_hu87a72e17709afdcf6c769a5cec04ba65_2863834_720x0_resize_box_3.png 720w ,https://ardent101.github.io/posts/shadow_creds/images/logo_hu87a72e17709afdcf6c769a5cec04ba65_2863834_1080x0_resize_box_3.png 1080w ,https://ardent101.github.io/posts/shadow_creds/images/logo_hu87a72e17709afdcf6c769a5cec04ba65_2863834_1500x0_resize_box_3.png 1500w ,https://ardent101.github.io/posts/shadow_creds/images/logo.png 1741w" sizes="(min-width: 768px) 720px, 100vw" src=https://ardent101.github.io/posts/shadow_creds/images/logo.png alt width=1741 height=2038></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Оглавление</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#вводная-теория>Вводная теория</a><ul><li><a href=#криптография-с-открытым-ключом>Криптография с открытым ключом</a></li><li><a href=#электронная-цифровая-подпись>Электронная цифровая подпись</a></li><li><a href=#центр-сертификации>Центр сертификации</a></li><li><a href=#pkinit-в-kerberos-active-directory>PKINIT в Kerberos Active Directory</a></li><li><a href=#физическое-хранение-закрытых-ключей>Физическое хранение закрытых ключей</a></li><li><a href=#ntlm-в-pkinit>NTLM в PKINIT</a></li><li><a href=#key-trust>Key Trust</a></li></ul></li><li><a href=#практическая-часть>Практическая часть</a><ul><li><a href=#passthecertificate>PassTheCertificate</a></li><li><a href=#unpac-the-hash>UnPAC the Hash</a></li><li><a href=#shadow-credentials>Shadow Credentials</a></li><li><a href=#enterprises-key-admin>Enterprises Key Admin</a></li></ul></li><li><a href=#заключение>Заключение</a></li><li><a href=#используемые-источники>Используемые источники</a></li></ul></nav></div></details></div><div class=post-content><p>В статье рассматривается устройство одного из расширений протокола Kerberos - PKINIT. После теоретической вводной будут разобраны техники проведения атак, связанные с указанным расширением, в частности: Shadow Credentials и UnPAC the hash.</p><p>Если вкратце, то первая техника позволяет атакующему закрепиться в домене, не смотря на смену паролей, а вторая получить NT-хеш пароля учетной записи при наличии права изменения атрибута msDS-KeyCredentialLink указанной учетной записи.</p><h2 id=вводная-теория>Вводная теория<a hidden class=anchor aria-hidden=true href=#вводная-теория>#</a></h2><p>PKINIT (Public Key Cryptography for Initial Authentication in Kerberos) - расширение протокола Kerberos, позволяющее использовать криптографию с открытом ключом на этапе предварительной аутентификации.</p><p>Зачем понадобилось это расширение? Какими преимуществами оно обладает?</p><blockquote><p>По-хорошему для грамотного ответа необходимо обладать специализированными знаниями в криптографии, а размышлять &ldquo;на пальцах&rdquo; о подобных вопросах неблагодарное занятие. Те кто ничего не знал вряд ли поймут, те кто знал сочтут за невежду. Тем не менее этот материал не является строгой научной статьей, поэтому попробую предоставить небольшую вводную для общего развития и лучшего понимания о чем идет речь.</p></blockquote><p>При оценке защищенности информационных ресурсов организации одним из наиболее типовых и классических недостатков является использование словарных или нестойких к атакам методом подбора паролей. Сам по себе протокол Kerberos никак не позволяет защититься от подобных атак (см. ранее про <a href=/posts/kerberos_general_attacks/#%D1%80%D0%B0%D1%81%D0%BF%D1%8B%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8F>распыление</a>). Безусловно в Active Directory есть возможность реализовать строгую парольную политику, кроме того можно осуществлять мониторинг журнала событий с целью выявления и пресечения указанных атак. В ряде случаев это работает, но как решить проблему &ldquo;на корню&rdquo;?</p><p>Начнем очень издалека. Пароль - что это вообще такое? В <a href=https://files.stroyinf.ru/Data2/1/4293722/4293722003.pdf>ГОСТ Р 58833-2020</a> &ldquo;<em>Защита информации. Идентификация и аутентификация. Общие положения</em>&rdquo; есть следующее определение:</p><p>Пароль - конфиденциальная аутентификационная информация, обычно состоящая из строки знаков.</p><p>Ключевое слово - &ldquo;обычно&rdquo;. Действительно в качестве пароля также могут выступать: аппаратные токены, отпечатки пальцев, сетчатка глаза, голос, да мало ли что еще. Более того пароль может включать в себя сразу несколько факторов, например смарт карта с пин кодом.</p><blockquote><p>Оффтоп: следует различать двухфакторною и двухэтапную аутентификацию, чуть более подробно простым языком об этом можно прочитать <a href=https://www.outsidethebox.ms/18372/>здесь</a>.</p></blockquote><p>Пароли, &ldquo;состоящие из строки знаков&rdquo;, обладают рядом недостатков, а именно:</p><ul><li>пароли могут быть словарными</li><li>пароли надо помнить</li><li>пользователи могут непреднамеренно раскрыть свои пароли в ходе фишинговых атак, в почтовой переписке или в файле на общедоступном сетевом хранилище</li><li>при захвате сервера атакующий зачастую может извлечь пароль пользователя и использовать его для атаки методом повторного воспроизведения</li></ul><p>Расширение PKINIT помогает минимизировать приведенные выше проблемы в рамках Kerberos. PKINIT реализует поддержку протоколов с открытым ключом и в частности позволяет внедрить аутентификацию по сертификатам или двухфакторную аутентификацию. Таким образом PKINIT может гарантировать использование несловарных, стойких к атакам метода перебора паролей.</p><p>Далее попробуем разобраться, что такое &ldquo;открытый ключ&rdquo;.</p><h3 id=криптография-с-открытым-ключом>Криптография с открытым ключом<a hidden class=anchor aria-hidden=true href=#криптография-с-открытым-ключом>#</a></h3><p>Для начала рассмотрим, в чем разница между симметричным и ассиметричныи шифрованием.</p><p>При симметричном шифровании для шифрования и расшифрования данных используется один и тот же ключ, то есть от клиента и сервера требуется наличие общего одинакового секрета. В частности, именно этот вид шифрования по умолчанию используется в Kerberos в <a href=/posts/kerberos_theory/#krb_as_req>ходе</a> предварительной аутентификации.</p><p>При асимметричном шифровании используется пара математически связанных между собой ключей: открытый и закрытый. Закрытый хранится в тайне, в то время, как открытый является публичным. То, что было зашифровано на одном ключе, расшифровывается с использованием второго.</p><p>Для лучшего понимания рассмотрим следующую бытовую аналогию:</p><ul><li>При симметричном шифровании сообщение передается в ящике, закрытом на обычный замок. Ключ от замка хранится как у отправителя, так и у получателя. Для шифрования отправителю требуется положить сообщение в ящик и запереть его на замок с использованием ключа. Получатель открывает замок с помощью того же самого ключа и извлекает сообщение.</li></ul><p><figure><img src=images/symmetric.svg alt=symmetric_ecnryption><figcaption><p style=text-align:center>Общий принцип симметричного шифрования</p></figcaption></figure></p><ul><li>При асимметричном шифровании сообщение передается в ящике, закрытом на <em>необычный замок</em>. Особенность замка заключается в том, что для его закрытия ничего не требуется, замок достаточно только защелкнуть, а вот для открытия уже необходим ключ. Получатель создает много копий замка и раздает их всем желающим, а ключ хранит у себя в секрете. Каждый, кто хочет отправить сообщение, кладет его в ящик и закрывает его на защелкивающийся замок, открыть который может только получатель.</li></ul><p><figure><img src=images/session_exchange.svg alt=session_exchange><figcaption><p style=text-align:center>Схема передачи сессионного ключа с использованием ассиметричного шифрования</p></figcaption></figure></p><p>Симметричное шифрование работает быстро, но его узким местом является управление ключами, в частности возникают трудности при передаче общего секретного ключа по открытым каналам связи. Это важно при установлении защищенного соединения, например в сети Интернет.</p><p>Криптография с открытым (ассиметричным) ключом позволяет эффективно решить указанную проблему, но при этом работает медленнее. В итоге на практике используется сочетание двух видов шифрования.</p><p>Для лучшего понимания рассмотрим искусственный, но отчасти приближенный к реальности пример. Представим себе сеть, где для каждого пользователя имеется свой сервер, на котором развернута почта и личный блог с контактной информацией.</p><p>Рассмотрим возможный процесс обмена сообщениями в указанной сети:</p><p><figure><img src=images/open_key_exchange.svg alt=open_key_ecnryption><figcaption><p style=text-align:center>Общий принцип асимметричного шифрования</p></figcaption></figure></p><ol><li>Пользователь Алиса находит сайт пользователя Боб и в разделе с контактной информацией узнает открытый ключ Боба</li><li>Алиса генерирует секретный сессионный ключ, зашифровывает его с использованием открытого ключа Боба и отправляет получившиеся зашифрованное сообщение Бобу</li><li>Боб, получив сообщение, расшифровывает его с помощью своего закрытого ключа и получает сессионный ключ</li><li>Боб отправляет Алисе сообщение, зашифрованное с использованием полученного сессионного ключа. Дальнейшее общение шифруется на установленном сессионном ключе.</li></ol><p>Важно отметить, что указанный пример подвержен атаке &ldquo;человек по середине&rdquo;. Атакующий может навязать отправителю свой сервер, вместо сервера Боба, например с помощью ARP-spoofing. Подложный сервер может содержать копию сайта Боба, но уже с другим значением открытого ключа, секретный ключ к которому имеется у атакующего. В результате отправитель направит атакующему сообщение зашифрованное на подставном открытом ключе.</p><p>Возникает вопрос, как Алиса может убедиться в том, что открытый ключ Боба действительно принадлежит Бобу? То есть требуется аутентификация открытых ключей. Таким образом мы подошли к следующей теме.</p><h3 id=электронная-цифровая-подпись>Электронная цифровая подпись<a hidden class=anchor aria-hidden=true href=#электронная-цифровая-подпись>#</a></h3><p>Криптография с открытым ключом работает и в другую сторону. То, что было зашифровано с использованием закрытого ключа, может быть расшифровано с помощью соответствующего открытого ключа.</p><p>Какой в этом смысл? Допустим, что мы обладаем подлинным открытым ключом некого Боба и этот самый Боб хочет выступить с публичным сообщением от своего имени. Тогда:</p><ol><li>Боб пишет текст сообщения и зашифровывает его с использованием своего закрытого ключа</li><li>Боб публикует у себя на сайте зашифрованное сообщение</li><li>Любой желающий может расшифровать сообщение и прочитать его содержимое</li></ol><p>Тот факт, что сообщение было успешно расшифровано, свидетельствует о том, что оно было написано владельцем закрытого ключа, то есть Бобом. Тем самым способом возможно &ldquo;подписывать&rdquo; информацию.</p><p>Иными словами цифровая подпись позволяет получателю сообщения убедиться в аутентичности источника информации, а также проверить, была ли информация изменена (искажена), пока находилась в пути. Таким образом, цифровая подпись является средством аутентификации и контроля целостности данных.</p><p>На практике шифровать само сообщение ресурсозатратно, поэтому зашифровывается хеш сообщения, полученный с использованием специальной криптографической хеш-функции. Всюду далее к исходному сообщению прикладывается указанный шифрованный хеш, который и называют подписью. Любой желающий убедиться в подлинности должен самостоятельно вычислить хеш от сообщения и сравнить его с результатом расшифрования подписи.</p><h3 id=центр-сертификации>Центр сертификации<a hidden class=anchor aria-hidden=true href=#центр-сертификации>#</a></h3><p>Тем не менее проблема аутентификации открытых ключей пока остается нерешенной. Одним из решений является введение сертификации открытых ключей с помощью доверенной третьей стороны - центра сертификации. В этом случае перед публикацией своего открытого ключа пользователь должен обратиться в центр сертификации чтобы получить сертификат.</p><p>Сертификат открытого ключа может содержать множество полей, например:</p><ul><li>Имя пользователя</li><li>Открытый ключ пользователя</li><li>Срок действия сертификата</li><li>Наименование центра сертификации</li></ul><p>Но самым главным полем является <em>цифровая подпись</em>, представляющая собой хеш от всех полей сертификата, зашифрованный на закрытом ключе центра сертификации.</p><p>Рассмотрим пример процедуры обмена сообщениями при наличии центра сертификации:</p><p><figure><img src=images/PK_cert.svg alt=pk_cert><figcaption><p style=text-align:center>Пример обмена сообщений с использованием сертифицированного открытого ключа</p></figcaption></figure></p><ol><li>Алиса генерирует пару открытый / закрытый ключ.</li><li>Алиса аутентифицируется в центре сертификации и передает туда свои данные, в частности открытый ключ.</li><li>Центр сертификации проверяет полученные данные и подписывает их с использованием своего закрытого ключа. В результате получается сертификат открытого ключа, который передается Алисе.</li></ol><blockquote><p>Шаги 1-3 считаются стандартными для всех пользователей сети. Можно считать, что при регистрации каждый пользователь получает сертификат своего открытого ключа и открытый ключ Центра сертификации. Таким образом у Боба также есть сертификат для своего открытого ключа и открытый ключ Центра сертификации.</p></blockquote><ol start=4><li>Желая отправить сообщение, Боб с сайта Алисы извлекает открытый ключ и соответствующий ему сертификат. С помощью открытого ключа Центра сертификации Боб проверяет подлинность полученного сертификата. Боб доверяет Центру сертификации, а успешная проверка цифровой подписи сертификата означает, что Центр сертификации в свою очередь проверил принадлежность открытого ключа Алисе. Поэтому Боб может быть уверен, что извлеченный с сайта открытый ключ действительно принадлежит Алисе.</li><li>Боб шифрует сообщение с использованием открытого ключа Алисы и подписывает его с использованием своего закрытого ключа. Получившиеся данные передаются Алисе.</li><li>Получив сообщение, Алиса расшифровывает его с помощью своего закрытого ключа. Кроме того, благодаря электронной подписи Алиса может убедиться, что сообщение было отправлено именно Бобом. Таким образом обеспечивается взаимная аутентификация пользователей.</li></ol><blockquote><p>Любопытно отметить, что в рассмотренной схеме Центр сертификации необходим только при регистрации пользователя. Все остальное время Центр сертификации может быть вообще отключен.</p></blockquote><p>Приведенный пример иллюстрирует общую идею, что за счет введения дополнительной доверенной сущности возможно решить проблему управления открытыми ключами. На практике разумеется все устроено несколько сложнее.</p><p>Важно заметить, что с внедрением процедуры сертификации в домене появляется еще один доверительный центр.</p><p><figure><img src=images/trust_centre.svg alt=trust_center><figcaption><p style=text-align:center>Центры доверия с сертификацией и без</p></figcaption></figure></p><h3 id=pkinit-в-kerberos-active-directory>PKINIT в Kerberos Active Directory<a hidden class=anchor aria-hidden=true href=#pkinit-в-kerberos-active-directory>#</a></h3><p>Расширение PKINIT позволяет использовать криптографию с открытым ключом на этапе предварительной аутентификации Kerberos. В первой части уже был подробно рассмотрен <a href=/posts/kerberos_theory/#krb_as_req>этап</a> предварительной аутентификации. Вкратце напомню, что в &ldquo;традиционном&rdquo; случае от клиента и сервера требовалось знание общего симметричного ключа.</p><p>Теперь рассмотрим в первом приближении обмен сообщениями с использованием PKINIT:</p><p><figure><img src=images/AS_REQ_PKINIT.svg alt=pkinit_asreq><figcaption><p style=text-align:center>AS_REQ запрос с PKINIT</p></figcaption></figure></p><ol start=0><li>Клиент отправляет серверу аутентификации текущую метку времени, подписанную своим закрытым ключом, а также сертификат предназначенный для проверки подлинности передаваемого открытого ключа.</li><li>Сервер аутентификации проверяет при помощи открытого ключа центра сертификации проверяет подлинность полученного сертификата открытого ключа клиента.</li><li>С использованием проверенного открытого ключа клиента сервер аутентификации проверяет подпись метки времени и сравнивает её значение с текущим.</li></ol><p><figure><img src=images/AS_REP_PKINIT.svg alt=pkinit_asrep><figcaption><p style=text-align:center>AS_REP запрос с PKINIT</p></figcaption></figure></p><ol start=0><li>Сервер аутентификации отправляет ответ Клиенту.</li><li>Клиент с использованием своего закрытого ключа расшифровывает одну из частей принятого ответа.</li><li>В расшифрованной части клиент проверяет сертификат открытого ключа сервера аутентификации.</li><li>При помощи полученного открытого ключа сервера аутентификации клиент проверяет подпись AS-REP ключа.</li><li>С использованием AS-REP ключа Клиент расшифровывает сессионный ключ для общения с контроллером домена.</li><li>Клиент получает TGT и сессионный ключ для KDC.</li></ol><p>После передачи TGT и сессионного ключа остальные этапы Kerberos аутентификации производятся точно также, как в &ldquo;традиционном&rdquo; случае.</p><p>Дотошному читателю может быть не понятно, зачем использовать промежуточный симметричный ключ (см. шаг №3). Почему вместо указанного ключа сразу не передавать сессионный ключ? Насколько понимаю, дело в том, что симметричный ключ может вырабатываться разными методами, имеющие свои преимущества и недостатки. Так глубоко копать нет смысла, поэтому для примера мы рассмотрели один, наиболее распространенный метод. Кроме того необходимо понимать, что рассмотренный пример является упрощением и в реальности передаваемые сообщения содержат больше полей, в частности содержащие случайные метки и идентифицирующую информацию.</p><blockquote><p>Более подробно ознакомиться с устройством PKINIT можно в <a href=https://www.ietf.org/rfc/rfc4556.txt>RFC 4556</a></p></blockquote><h3 id=физическое-хранение-закрытых-ключей>Физическое хранение закрытых ключей<a hidden class=anchor aria-hidden=true href=#физическое-хранение-закрытых-ключей>#</a></h3><p>Остался незатронутым вопрос хранения пользователями своих закрытых ключей. Для этого могут использоваться различные специализированные внешние устройства (смарт-карты, токены и др.) или внутренние аппаратные модули (TPM). Подобные устройства обладают встроенными устойчивыми к взлому хранилищами данных, а также микросхемами позволяющими выполнять необходимые криптографические операции.</p><p>Закрытый ключ может быть импортирован на устройство или сгенерирован самим устройством самостоятельно. Для активации устройства с целью выполнения операций требующих знания закрытого ключа, как правило необходимо пройти дополнительную проверку, например ввести пин-код.</p><p>Таким образом обеспечивается двухфакторная аутентификация. Первый фактор - (чем обладаю?) физическое устройство, второй фактор (что знаю?) - пин-код.</p><p>Двухфакторная аутентификация в Kerberos обладает множеством преимуществ:</p><ul><li>Гарантируется использование псевдослучайных длинных паролей.</li><li>Исключается возможность хранения пароля в незащищенном месте, например в записке на рабочем столе или в файле на общедоступной сетевой папке.</li><li>Пароль нельзя случайно разболтать или отправить третьему лицу, таким образом минимизируются фишинговые атаки.</li></ul><p>Тем не менее существует ряд мифов, которые стоит развенчать.</p><p><strong>Миф 1</strong>: Использование внешнего устройства при двухфакторной аутентификации позволяет безопасно осуществлять вход в домен с незащищенных рабочих станций, так как вся ключевая информация хранится на изолированном носителе.</p><ul><li>Это утверждение некорректно. Как минимум на указанном рабочем месте будет присутствовать активный в течении нескольких часов TGT, скорее всего позволяющий продлить срок действия до 7 суток.</li></ul><p><strong>Миф 2</strong>: При использование двухфакторной аутентификации по Kerberos исключается использование протокола NTLM.</p><ul><li>Это неправда. Двухфакторная аутентификация в Kerberos может осуществляться с применением протокола NTLM. Подробнее почему так и как это можно эксплуатировать рассмотрим дальше.</li></ul><h3 id=ntlm-в-pkinit>NTLM в PKINIT<a hidden class=anchor aria-hidden=true href=#ntlm-в-pkinit>#</a></h3><p>Представим, что организация внедрила в Active Directory аутентификацию с использованием смарт-карт по протоколу Kerberos, но как быть с ресурсами, которые поддерживают вход только по NTLM?</p><p>Для того, чтобы лучше разобраться в этом вопросе рассмотрим процесс интерактивного входа пользователя на рабочую станцию по смарт-карте с использованием расширения PKINIT.</p><p>Пользователь вставляет смарт-карту в устройство для чтения и вводит пароль. Далее PA_PK_AS_REQ-сообщение отправляется также, как было рассмотрено <a href=#ntlm-%D0%B2-pkinit>ранее</a>. Отличия начинаются на втором шаге. Сервер аутентификации возвращает TGT, содержащий в <a href=/posts/kerberos_theory/#krb_as_rep-ad>PAC</a> NT-хеш пароля клиента, зашифрованный на AS-REP ключе. После получения PA_PK_AS_REP-сообщения клиент не может получить доступ к своему NT-хешу, так как не знает секрет KDC, с использованием которого зашифрован TGT.</p><p><figure><img src=images/PKINIT_SmartCard.svg alt=smart_asreq><figcaption><p style=text-align:center>PA_PK_AS_REP при использовании смарт-карты</p></figcaption></figure></p><p>Далее клиент отправляет контроллеру домена запрос на получение TGS билета для доступа к рабочей станции. Обратите внимание, что в качестве принципала сервиса указывается <em>host/hostname.domain</em>.</p><p><figure><img src=images/SmartCard_TGS_REQ.svg alt=smart_tgs_req><figcaption><p style=text-align:center>TGS_REQ при использовании смарт-карты</p></figcaption></figure></p><p>Контроллер домена копирует PAC, извлеченный из TGT, в TGS билет и отправляет получившийся TGS билет клиенту. Теперь вспоминаем, что речь идет об интерактивном входе в систему, то есть &ldquo;секрет хоста&rdquo; считается известным значением в рамках рабочей станции.</p><p>Система предоставит доступ для клиента, но гораздо важнее, что система расшифрует NT-хеш клиента с помощью AS-REP ключа и поместит указанный NT-хеш в кэш LSA. В дальнейшем в случае если какой-либо сервис не сможет работать по протоколу Kerberos, система использует для аутентификации хранящийся в LSA NT-хеш.</p><p><figure><img src=images/KRB_TGS_REP.svg alt=smart_tgs_rep><figcaption><p style=text-align:center>TGS_REP при использовании смарт-карты</p></figcaption></figure></p><p>Таким образом внедрение смарт-карт не исключает применения протокола NTLM.</p><p>Дополнительно почитать об аутентификации по смарт-картам можно в следующих источниках:</p><ul><li><a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-PKCA/%5bMS-PKCA%5d.pdf>MS-PKCA - Раздел 4</a></li><li><a href=https://zer0tru5t.com/leave-the-door-0pen-abusing-5martcard-authentication-with-anderson-pac/>Leave the Door 0pen – Abusing 5martcard Authentication with Anderson PAC</a> - Eran Nachshon.</li><li><a href=https://research.nccgroup.com/wp-content/uploads/2020/07/weaknesses_and_best_practices_of_public_key_kerberos_with_smart_cards.pdf>&ldquo;Weaknesses and Best Practices of Public Key Kerberos with Smart Cards&rdquo;</a> Brad Hill.</li></ul><h3 id=key-trust>Key Trust<a hidden class=anchor aria-hidden=true href=#key-trust>#</a></h3><p>Рассмотренный ранее пример аутентификации с помощью центров сертификации и смарт-карт представляет модель доверия на основе сертификатов. Исторически это одна из первых моделей, реализованных в Active Directory, но со временем были добавлены и другие модели. В частности Microsoft в ходе разработки Windows Hello внедрила в Windows Server 2016 новую модель доверия под названием Key Trust.</p><blockquote><p>Рассказ про Windows Hello заслуживает отдельного материала. Вкратце и грубо Windows Hello - технология позволяющая осуществлять двухфакторную аутентификацию, в том числе с использованием биометрии (отпечаток пальца, радужная оболочка глаза, распознавание лица), при помощи встроенных функций операционных систем семейства Windows. Работает указанная технология как для персональных компьютеров, так и в домене (Windows Hello for Business).<br><br>Более подробно ознакомиться с Windows Hello можно по следующим ссылкам:<br><a href=https://www.dsinternals.com/assets/documents/eu-19-Grafnetter-Exploiting-Windows-Hello-for-Business.pdf>&ldquo;Exploiting Windows Hello for Business&rdquo;</a>, BlackHat, 2019 год.<br><a href=https://learn.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/>Официальная документация Windows Hello</a></p></blockquote><p>В Key Trust контроллер домена для проверки подлинности ключа клиента использует не сертификат, а специальный атрибут <em>msDS-KeyCredentialLink</em> содержащий открытый ключ учетной записи указанного клиента. Если быть точнее, то атрибут <em>msDS-KeyCredentialLink</em> является многозначным, так как у учетной записи может быть несколько устройств с которых она осуществляет вход в систему. Такое возможно, например, если у пользователя две рабочих станции, и соответственно для хранения закрытых ключей используются разные модули TPM.</p><p>При рассмотрении Key Trust может возникнуть ошибочное ощущение, что необходимость в центре сертификации теперь отсутствует. На самом деле это не так. Дело в том, что клиенты должны быть способны проверить подлинность открытого ключа контроллера домена, а для этого все же требуется сертификат, а значит и центр сертификации.</p><p>Таким образом в Key Trust клиенты <a href=https://learn.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/hello-how-it-works-authentication#azure-ad-join-authentication-to-active-directory-using-a-key>проверяют</a> подлинность контроллера домена по сертификату открытого ключа, а контроллер в свою очередь проверяет подлинность получаемых сообщений, пытаясь расшифровать их открытым ключом из атрибута учетной записи.</p><h2 id=практическая-часть>Практическая часть<a hidden class=anchor aria-hidden=true href=#практическая-часть>#</a></h2><p>Как представленная выше информация может пригодиться при тестировании на проникновение?</p><p>Во вступлении уже были анонсированы атаки Shadow Credentials и UnPAC the Hash, но есть и другие атаки. Теперь перейдем к детальному разбору возможных атак и тонкостей при их реализации.</p><h3 id=passthecertificate>PassTheCertificate<a hidden class=anchor aria-hidden=true href=#passthecertificate>#</a></h3><p><strong>Условия для проведения атаки</strong>: наличие ключевой пары и соответствующего сертификата от учетной записи пользователя.</p><p><strong>Результат успешной атаки</strong>: доступ к ресурсам домена с правами атакуемой учетной записи.</p><p>Начнем с наиболее простой атаки PassTheCertificate (PtC). По сути PassTheCertificate не атака, а полезный кирпичик будущих атак, представляющий собой легитимное действие.</p><p>Для начала рассмотрим в каких форматах могут храниться ключи с сертификатами. Как правило, сталкиваться придется с файлами в формате PEM или PFX.</p><p><strong>PEM</strong> - включает файлы со следующими расширениями:</p><ul><li>.pem - предназначен для хранения открытого ключа учетной записи и сертификата к нему</li><li>.key - содержит закрытый ключ учетной записи</li></ul><p><strong>PFX</strong> - содержит открытый, закрытый ключи учетной записи и сертификат в одном файле, который зашифрован с использованием пароля.</p><p>Чуть более подробно почитать о форматах файлов криптографических ключей можно <a href=https://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file/9717#9717>здесь</a>.</p><p>При наличие указанных файлов возможно осуществить аутентификацию и получить TGT к учетной записи для которой предназначались ключи.</p><p><strong>Команды для выполнения атаки в Linux</strong>:</p><p>Для работы с PKINIT в Linux существует набор скриптов <a href=https://github.com/dirkjanm/PKINITtools/>PKINITtools</a> за авторством <a href=https://dirkjanm.io/>Dirk-jan</a>.</p><p>Для аутентификации по сертификату воспользуемся утилитой <a href=https://github.com/dirkjanm/PKINITtools/blob/master/gettgtpkinit.py>gettgtpkinit.py</a></p><p>Аутентификация по сертификату в формате PFX:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gettgtpkinit.py -cert-pfx <span class=s2>&#34;PATH_TO_PFX_CERT&#34;</span> -pfx-pass <span class=s2>&#34;CERT_PASSWORD&#34;</span> <span class=s2>&#34;FQDN_DOMAIN/TARGET_SAMNAME&#34;</span> <span class=s2>&#34;TGT_CCACHE_FILE&#34;</span>
</span></span></code></pre></div><p>Аутентификация по сертификату в формате PFX, кодированном в Base64:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gettgtpkinit.py -pfx-base64 <span class=k>$(</span>cat <span class=s2>&#34;PATH_TO_B64_PFX_CERT&#34;</span><span class=k>)</span> <span class=s2>&#34;FQDN_DOMAIN/TARGET_SAMNAME&#34;</span> <span class=s2>&#34;TGT_CCACHE_FILE&#34;</span>
</span></span></code></pre></div><p>Аутентификация по сертификату в формате PEM:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gettgtpkinit.py -cert-pem <span class=s2>&#34;PATH_TO_PEM_CERT&#34;</span> -key-pem <span class=s2>&#34;PATH_TO_PEM_KEY&#34;</span> <span class=s2>&#34;FQDN_DOMAIN/TARGET_SAMNAME&#34;</span> <span class=s2>&#34;TGT_CCACHE_FILE&#34;</span>
</span></span></code></pre></div><p><strong>Команды для выполнения атаки в Windows</strong>:</p><p>Rubeus поддерживает работу с PFX-сертификатами, кодированными в Base64:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Rubeus.exe asktgt /user:<span class=s2>&#34;TARGET_SAMNAME&#34;</span> /certificate:<span class=s2>&#34;BASE64_CERTIFICATE&#34;</span> /password:<span class=s2>&#34;CERTIFICATE_PASSWORD&#34;</span> /domain:<span class=s2>&#34;FQDN_DOMAIN&#34;</span> /dc:<span class=s2>&#34;DOMAIN_CONTROLLER&#34;</span> /show
</span></span></code></pre></div><p>В Windows сконвертировать PEM в PFX возможно с помощью openssl:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>openssl pkcs12 -in <span class=s2>&#34;cert.pem&#34;</span> -keyex -CSP <span class=s2>&#34;Microsoft Enhanced Cryptographic Provider v1.0&#34;</span> -export -out <span class=s2>&#34;cert.pfx&#34;</span>
</span></span></code></pre></div><p>В продолжение PassTheCertificate логично использовать PassTheTicket (<a href=/posts/kerberos_general_attacks/#pass-the-ticket-ptt--pass-the-cache>PassTheTicket</a>), но есть и другие атаки которые будут рассмотрены далее.</p><p>Источник информации - <a href=https://www.thehacker.recipes/ad/movement/kerberos/pass-the-certificate>thehacker.recipes</a></p><h3 id=unpac-the-hash>UnPAC the Hash<a hidden class=anchor aria-hidden=true href=#unpac-the-hash>#</a></h3><p><strong>Условия для проведения атаки</strong>: наличие ключевой пары и соответствующего сертификата к учетной записи.</p><p><strong>Результат успешной атаки</strong>: NT-хеш пароля учетной записи.</p><p>TGT это хорошо, но NT-хеш еще лучше. Для того, чтобы разобраться в атаке UnPAC the Hash рассмотрим, как устроена аутентификация User-to-User (U2U) по протоколу Kerberos.</p><h4 id=user-to-user-аутентификация>User-to-User аутентификация<a hidden class=anchor aria-hidden=true href=#user-to-user-аутентификация>#</a></h4><p>U2U-аутентификация изначально задумывалась, чтобы обычные пользователи на своих рабочих станциях могли предоставлять другим пользователям некоторые сервисы, например NFS или FTP.</p><p>Рабочая станция пользователя считается незащищенным объектом, поэтому использовать её для хранения долговременных секретов нецелесообразно. В этом случае в TGS-билете в качестве секрета сервиса применяется кратковременный сессионный &ldquo;ключ пользователя для KDC&rdquo;. Но ведь KDC не хранит сессионные ключи, а извлекает их из TGT. Тогда как же KDC зашифровывает TGS-билет?</p><p>Для лучшего понимания происходящего пошагово разберем этапы U2U-аутентификация.</p><p><figure><img src=images/U2U_auth.svg alt=u2u_auth><figcaption><p style=text-align:center>1. Начало U2U аутентификации</p></figcaption></figure></p><ol><li>Алиса проходит аутентификацию к Сервису Боба и предъявляет TGS-билет, зашифрованный с использованием долговременного секрета Боба (например NT-хеша). Сервис Боба не способен расшифровать предъявляемый TGS-билет, так как указанный сервис работает на рабочей станции и не имеет доступа к долговременному ключу Боба. Поэтому в ответ Сервис Боба отправляет сообщение о том, что должен использоваться механизм U2U и прилагает TGT Боба.</li></ol><blockquote><p>Передавать TGT в открытом виде нормально, несмотря на то что весь сетевой трафик считается известным третье стороне. Более того именно так и делается в <a href=/posts/kerberos_theory/#krb_as_rep>KRB_AS_REP</a>. Сам по себе TGT Боба без знания сессионного ключа для KDC не представляет никакой ценности и не позволяет проводить атаку <a href=/posts/kerberos_general_attacks/#pass-the-ticket-ptt--pass-the-cache>PassTheTicket</a>.</p></blockquote><p><figure><img src=images/U2U_TGS_REQ.svg alt=u2u_tgs_req><figcaption><p style=text-align:center>2. TGS_REQ при U2U аутентификации</p></figcaption></figure></p><ol start=2><li>Алиса запрашивает у контроллера домена TGS-билет с использованием U2U-аутентификации, о чем свидетельствует специальный флаг. Кроме того, в качестве дополнительного билета Алиса прилагает TGT Боба. Контроллер домена в свою очередь извлекает из полученных TGT сессионные ключи Алисы и Боба.</li></ol><p><figure><img src=images/U2U_TGS_REP.svg alt=u2u_tgs_rep><figcaption><p style=text-align:center>3. TGS_REP при U2U аутентификации</p></figcaption></figure></p><ol start=3><li>Контроллер домена отправляет Алисе TGS-билет зашифрованный с использованием извлеченного на предыдущем шаге сессионного ключа Боба.</li></ol><p><figure><img src=images/U2U_AP_REQ.svg alt=u2u_tgs_rep><figcaption><p style=text-align:center>4. AP_REQ при U2U аутентификации</p></figcaption></figure></p><ol start=4><li>Теперь Сервис Боба может расшифровать полученный TGS-билет и предоставить доступ для Алисы.</li></ol><blockquote><p>Использование кратковременного ключа в качестве секрета также не позволяет провести Kerberoasting в отношении простых пользователей.</p></blockquote><p>В итоге зачем были нужны непростые объяснения всех этих механизмов?</p><h4 id=объяснение-атаки-unpac-the-hash>Объяснение атаки UnPAC the Hash<a hidden class=anchor aria-hidden=true href=#объяснение-атаки-unpac-the-hash>#</a></h4><p>Дело в том, что пользователь может осуществить PKINIT + U2U запрос на аутентификацию к самому себе и таким образом получить свой NT-хеш.</p><p>Для начала представим, что Алиса уже получила TGT с использованием PKINIT, как это было рассмотрено <a href=/posts/shadow_creds/#ntlm-%D0%B2-pkinit>ранее</a>.</p><p><figure><img src=images/unpac_req.svg alt=unpac_tgs_req><figcaption><p style=text-align:center>U2U_TGS_REQ при аутентификации к "самому себе"</p></figcaption></figure></p><p>Алиса обращается к KDC с запросом U2U-аутентификации к своему же сервису и предоставляет в качестве дополнительного билета свой TGT, полученный в результате PKINIT и при этом содержащий PAC со своим NT-хешем.</p><p><figure><img src=images/unpac_rep.svg alt=unpac_tgs_rep><figcaption><p style=text-align:center>U2U_TGS_REP при аутентификации к "самому себе"</p></figcaption></figure></p><p>Контроллер домена возвращает Алисе TGS-билет, зашифрованный с использованием сессионного ключа Алисы для KDC. Алиса расшифровывает TGS-билет при помощи своего сессионного ключа, а затем расшифровывает свой NT-хеш при помощи AS-REP ключа.</p><p>Таким образом обладая ключевой парой и соответствующим сертификатом от учетной записи, возможно узнать NT-хеш пароля указанной учетной записи. На практике атака PassTheCert в связке с UnPAC the Hash активно используются для эксплуатации результатов других атак.</p><p><strong>Команды для выполнения атаки в Linux</strong>:</p><p>Сначала запрашиваем TGT при помощи PKINIT:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gettgtpkinit.py -cert-pfx <span class=s2>&#34;PATH_TO_CERTIFICATE&#34;</span> -pfx-pass <span class=s2>&#34;CERTIFICATE_PASSWORD&#34;</span> <span class=s2>&#34;FQDN_DOMAIN/TARGET_SAMNAME&#34;</span> <span class=s2>&#34;TGT_CCACHE_FILE&#34;</span>
</span></span></code></pre></div><p>С использованием полученного TGT и AS-REP ключа (отобразится в консоли в результате выполнения gettgtpkinit) получаем NT-хеш:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>KRB5CCNAME</span><span class=o>=</span><span class=s2>&#34;TGT_CCACHE_FILE&#34;</span>
</span></span><span class=line><span class=cl>getnthash.py -key <span class=s1>&#39;AS-REP key&#39;</span> <span class=s1>&#39;FQDN_DOMAIN&#39;</span>/<span class=s1>&#39;TARGET_SAMNAME&#39;</span>
</span></span></code></pre></div><p><strong>Команды для выполнения атаки в Windows</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Rubeus.exe asktgt /getcredentials /user:<span class=s2>&#34;TARGET_SAMNAME&#34;</span> /certificate:<span class=s2>&#34;BASE64_CERTIFICATE&#34;</span> /password:<span class=s2>&#34;CERTIFICATE_PASSWORD&#34;</span> /domain:<span class=s2>&#34;FQDN_DOMAIN&#34;</span> /dc:<span class=s2>&#34;DOMAIN_CONTROLLER&#34;</span> /show
</span></span></code></pre></div><p>Источники информации:</p><ul><li><a href=https://datatracker.ietf.org/doc/html/draft-ietf-cat-user2user-02>User to User Kerberos Authentication using GSS-API</a></li><li><a href=http://www.di-srv.unisa.it/~ads/corso-security/www/CORSO-0001/kerberos/ref/kerberos-faq.html#u2uauth>Kerberos F.A.Q.</a></li><li><a href=http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TM-424.pdf>Workstation Services and Kerberos Authentication at Project Athena</a></li><li><a href=https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash>Hacker Recipes - UnPAC the Hash</a></li></ul><h3 id=shadow-credentials>Shadow Credentials<a hidden class=anchor aria-hidden=true href=#shadow-credentials>#</a></h3><p><strong>Условия для проведения атаки</strong>:</p><ul><li>Хотя бы один контроллер домена функционирует под управлением ОС Windows Server 2016 или выше</li><li>Функциональный уровень домена Active Directory - Windows Server 2016</li><li>Контроллер домена обладает сертификатом для своего открытого ключа</li><li>Возможность осуществить запись в атрибут msDS-KeyCredentialLink целевой учетной записи</li></ul><p><strong>Результат успешной атаки</strong>: доступ к ресурсам домена с правами атакуемой учетной записи (NT-хеш).</p><p>Если атакующий обладает правом на запись в атрибут <em>msDS-KeyCredentialLink</em> некоторой учетной записи, то тогда он может поступить следующим образом:</p><ol><li>Самостоятельно сгенерировать пару открытый-закрытый ключ</li><li>Записать открытый ключ в атрибут <em>msDS-KeyCredentialLink</em> атакуемой учетной записи (см. <a href=/posts/shadow_creds/#key-trust>ранее</a>)</li><li>Осуществить атаку <a href=/posts/shadow_creds/#passthecertificate>Pass the Certificate</a></li><li>Осуществить атаку <a href=/posts/shadow_creds/#unpac-the-hash>UnPAC the Hash</a> и получить NT-хеш пароля атакуемой учетной записи</li></ol><blockquote><p>Наличие права на запись в атрибут <em>msDS-KeyCredentialLink</em> является частным случаем наличия следующих прав: GenericAll, GenericWrite, WriteOwner, WriteDACL.</p></blockquote><h4 id=реализация-атаки>Реализация атаки<a hidden class=anchor aria-hidden=true href=#реализация-атаки>#</a></h4><p>В 2022 году на конференции Phdays Шлюндин Павел представил доклад <a href="https://www.youtube.com/watch?v=1Abt_Jpx2nM">&ldquo;Другой взгляд атакующего на ACL в AD&rdquo;</a> в котором среди прочего мимоходом рассматривается эксплуатация права записи в атрибут <em>msDS-KeyCredentialLink</em>.</p><p>Более того, автор выложил в открытый доступ тренировочный <a href=https://disk.yandex.ru/d/Phn1DvKSTLzUxw>образ</a> виртуальной машины со специально установленными уязвимыми настройками, а также инструмент <a href=https://github.com/PShlyundin/ldap_shell>ldap_shell</a>, предназначенный для автоматизации эксплуатации атак на ACL.</p><p>Для демонстрации атаки Shadow Credentials на практике воспользуемся предоставленной виртуальной машиной (redteam.bro/user:P@ssw0rd).</p><p>Выявить право на запись в атрибут <em>msDS-KeyCredentialLink</em> или равноценное право возможно с помощью BloodHound. Отдельно возможность записи в атрибут <em>msDS-KeyCredentialLink</em> отображается с помощью ребра <em>AddKeyCredentialLink</em>, но мы рассмотрим более общий случай.</p><p><figure><img src=images/practice/RedTeam_BH_short.PNG alt=RedTeam_BH><figcaption><p style=text-align:center>Часть цепочки атаки, построенной с использованием BH</p></figcaption></figure></p><p>Из анализа видно, что пользователь User опосредованно обладает правом <em>GenericWrite</em> (позволяет осуществлять запись в атрибут <em>msDS-KeyCredentialLink</em>) в отношении User1. Для реализации атаки воспользуемся утилитой <a href=https://github.com/PShlyundin/ldap_shell>ldap_shell</a>.</p><p>Для начала выполним шаги, избавляющие от опосредованности и подводящие к интересующей нас атаке Shadow Credentials:</p><p><figure><img src=images/practice/helpdesk_short.PNG alt=RedTeam_BH><figcaption><p style=text-align:center>Необязательный этап</p></figcaption></figure></p><p>Теперь непосредственно проведем атаку Shadow Credentials:</p><p><figure><img src=images/practice/ldap_shell_shadow.PNG alt=RedTeam_BH><figcaption><p style=text-align:center>Эксплуатация Shadow Credentials с помощью ldap_shell</p></figcaption></figure></p><p>Существуют и другие инструменты для реализации указанной атаки. Посмотреть больше примеров эксплуатации атаки Shadow Credentials можно в прохождениях машины Outdated на HackTheBox (<a href=https://threatninja.net/2022/09/hack-the-box-outdated-machine-walkthrough-medium-difficulty/>пример</a>).</p><p><strong>Команды для выполнения атаки в Windows</strong>:</p><p>Одним из первых инструментов, эксплуатирующих Shadow Credentials был <a href=https://github.com/eladshamir/Whisker>Whisker</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Whisker.exe add /target:<span class=s2>&#34;TARGET_SAMNAME&#34;</span> /domain:<span class=s2>&#34;FQDN_DOMAIN&#34;</span> /dc:<span class=s2>&#34;DOMAIN_CONTROLLER&#34;</span> /path:<span class=s2>&#34;cert.pfx&#34;</span> /password:<span class=s2>&#34;pfx-password&#34;</span>
</span></span></code></pre></div><p><strong>Команды для выполнения атаки в Linux</strong>:</p><p>Со временем был создан клон Whisker на python - <a href=https://github.com/ShutdownRepo/pywhisker>PyWhisker</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pywhisker.py -d <span class=s2>&#34;FQDN_DOMAIN&#34;</span> -u <span class=s2>&#34;user1&#34;</span> -p <span class=s2>&#34;CERTIFICATE_PASSWORD&#34;</span> --target <span class=s2>&#34;TARGET_SAMNAME&#34;</span> --action <span class=s2>&#34;list&#34;</span>
</span></span></code></pre></div><p><figure><img src=images/tips_to_know.jpg alt=tips><figcaption><p style=text-align:center>Пример реализации атаки Shadow Credentials от PTSwarm</p></figcaption></figure></p><h4 id=преимущества-shadow-credentials>Преимущества Shadow Credentials<a hidden class=anchor aria-hidden=true href=#преимущества-shadow-credentials>#</a></h4><p>Существуют другие способы эксплуатации Generic-прав. Проведем небольшое сравнение:</p><ul><li>в отличие от <a href=/posts/kerberos_rbcd/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0-%D0%BD%D0%B0-rbcd>RBCD</a> эксплуатация Shadow Credentials не требует создания новой машинной учетной записи, удалить которую возможно только при наличии прав уровня администратора домена</li><li>в отличие от <a href=/posts/kerberos_general_attacks/#%D1%86%D0%B5%D0%BB%D0%B5%D0%B2%D0%BE%D0%B9-kerberoasting>Целевого Kerberoasting</a> эксплуатация Shadow Credentials занимает непродолжительное время и не зависит от сложности текущего пароля пользователя</li></ul><p>Кроме того, эксплуатация Shadow Credentials имеет другие преимущества:</p><ul><li>Не требует перезаписи пароля к учетной записи, что иногда расценивается как отказ в обслуживании и не допускается при проведении тестирования на проникновение</li><li>Позволяет закрепиться в домене, так как даже при смене пароля к скомпрометированной учетной записи атакующий сохраняет возможность аутентифицироваться по сгенерированной ключевой паре с помощью PKINIT.</li><li>Атакующему не требуется наделять дополнительными правами доступа какой-либо из легитимных объектов домена, компрометация которого впоследствии может быть выявлена.</li><li>Закрепление особенно актуально применительно к машинным учетным записям, потому что пароли машинных учетных записей обновляются каждый 30 дней. Кроме того машинные учетные записи могут самостоятельно осуществлять запись в свой атрибут <em>msDS-KeyCredentialLink</em> в случае если указанный атрибут пустой.</li></ul><blockquote><p>Пользовательские учетные записи не могут самостоятельно изменить свой атрибут <em>msDS-KeyCredentialLink</em>.</p></blockquote><h4 id=relay-атака>Relay атака<a hidden class=anchor aria-hidden=true href=#relay-атака>#</a></h4><p>Эксплуатировать Shadow Credentials возможно в том числе в ходе Relay-атаки.</p><p>Что такое Relay атака и как её осуществлять, заслуживает отдельного материала, но для тех кто хоть немного в теме приведу пример с необходимыми аргументами командной строки:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ntlmrelayx.py -t ldap://dc-ip --shadow-credentials
</span></span></code></pre></div><p>Источники:</p><p><a href=https://www.trustedsec.com/blog/a-comprehensive-guide-on-relaying-anno-2022/>I’m bringing relaying back: A comprehensive guide on relaying anno 2022</a></p><h3 id=enterprises-key-admin>Enterprises Key Admin<a hidden class=anchor aria-hidden=true href=#enterprises-key-admin>#</a></h3><p>Во многих инструментах (BloodHound, Pingcastle), выполняющих анализ небезопасных настроек Active Directory, особое внимание уделяется членству пользователей домена в определенных группах, например: Backup Operators, Account Operators, Server Operators и др.</p><p>Чуть подробнее об этом можно прочитать в следующих материалах:</p><ul><li><a href=https://cube0x0.github.io/Pocing-Beyond-DA/>Poc’ing Beyond Domain Admin - Part 1</a></li><li><a href="https://adsecurity.org/?p=3700">Beyond Domain Admins – Domain Controller & AD Administration</a></li></ul><p>Дело в том, что члены указанных групп неявно обладают правами уровня администратора домена. По умолчанию приведенные группы не содержат никаких членов за некоторым исключением, но в реальности в них можно встретить нестандартные учетные записи.</p><p>Применительно к теме статьи в Active Directory существуют две встроенные группы &ldquo;Key Admins&rdquo; и &ldquo;Enterprise Key Admins&rdquo;. Члены указанных групп обладают правом на изменение атрибута ms-DS-Key-Credential-Link для объектов компьютер, что позволяет осуществлять атаку Shadow Credentials.</p><p>В BloodHound наличие пользователей в группе &ldquo;Key Admins&rdquo; можно проверить следующим запросом:</p><pre tabindex=0><code>match (u:User)-[:MemberOf]-&gt;(g:Group {name:&#34;KEY ADMINS@DOMAIN.LOCAL&#34;}) return u.name
</code></pre><h2 id=заключение>Заключение<a hidden class=anchor aria-hidden=true href=#заключение>#</a></h2><p>В настоящем материале были рассмотрены некоторые основные принципы работы расширения PKINIT и сертификатов в Active Directory. В дальнейшем были разобраны типовые техники атак с использованием рассмотренных принципов, а также приведены практические примеры и команды для реализации указанных атак.</p><h2 id=используемые-источники>Используемые источники<a hidden class=anchor aria-hidden=true href=#используемые-источники>#</a></h2><ul><li><a href=https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab>&ldquo;Shadow Credentials: Abusing Key Trust Account Mapping for Account Takeover&rdquo;</a></li><li>Книга <a href=https://www.amazon.com/Kerberos-Definitive-Guide-Jason-Garman/dp/0596004036>&ldquo;Kerberos: The Definitive Guide&rdquo;</a> за авторством Jason Garman</li><li><a href=https://www.thehacker.recipes>Hacker Recipes</a></li><li>Telegram канал <a href=https://t.me/cyb3r53cr3t5>&ldquo;CyberSecrets&rdquo;</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ardent101.github.io/tags/active-directory/>Active Directory</a></li><li><a href=https://ardent101.github.io/tags/kerberos/>Kerberos</a></li><li><a href=https://ardent101.github.io/tags/pentest/>Pentest</a></li><li><a href=https://ardent101.github.io/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F/>Теория</a></li><li><a href=https://ardent101.github.io/tags/pkinit/>PKINIT</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on twitter" href="https://twitter.com/intent/tweet/?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT&url=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f&hashtags=ActiveDirectory%2cKerberos%2cPentest%2c%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f%2cPKINIT"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f&title=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT&summary=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT&source=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f&title=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on whatsapp" href="https://api.whatsapp.com/send?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT%20-%20https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 6. PKINIT on telegram" href="https://telegram.me/share/url?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%206.%20PKINIT&url=https%3a%2f%2fardent101.github.io%2fposts%2fshadow_creds%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ardent101.github.io/>Ardent101</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="копировать";function s(){e.innerText="скопировано!",setTimeout(()=>{e.innerText="копировать"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>