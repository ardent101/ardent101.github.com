<!doctype html><html lang=ru dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория | Ardent101</title><meta name=keywords content="Active Directory,Kerberos,Pentest,Теория"><meta name=description content="Вступление На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:
 Знание устройства протокола Kerberos необходимо для понимания ряда классических атак. Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно. Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать."><meta name=author content="Ardent101"><link rel=canonical href=https://ardent101.github.io/posts/kerberos_theory/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d6ed90c28450051e5bafcc0bf4bfe033ff2b04454909211dc9e97b8a50525621.css integrity="sha256-1u2QwoRQBR5br8wL9L/gM/8rBEVJCSEdyel7ilBSViE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ardent101.github.io/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ardent101.github.io/static/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ardent101.github.io/static/favicon-32x32.png><link rel=apple-touch-icon href=https://ardent101.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ardent101.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория"><meta property="og:description" content="Вступление На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:
 Знание устройства протокола Kerberos необходимо для понимания ряда классических атак. Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно. Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать."><meta property="og:type" content="article"><meta property="og:url" content="https://ardent101.github.io/posts/kerberos_theory/"><meta property="og:image" content="https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-05T11:30:03+00:00"><meta property="article:modified_time" content="2022-08-05T11:30:03+00:00"><meta property="og:site_name" content="Ardent101"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo.jpg"><meta name=twitter:title content="Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория"><meta name=twitter:description content="Вступление На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:
 Знание устройства протокола Kerberos необходимо для понимания ряда классических атак. Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно. Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ardent101.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория","item":"https://ardent101.github.io/posts/kerberos_theory/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория","name":"Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория","description":"Вступление На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:\n Знание устройства протокола Kerberos необходимо для понимания ряда классических атак. Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно. Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать.","keywords":["Active Directory","Kerberos","Pentest","Теория"],"articleBody":"Вступление На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:\n Знание устройства протокола Kerberos необходимо для понимания ряда классических атак. Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно. Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать.  Про Kerberos и атаки на него уже написано немало статей. Многие из указанных статей предназначены либо для математиков, либо для сетевых инженеров, либо для специалистов по тестированию на проникновение. Материал часто преподносится однобоко в разрозненной форме и приходится тратить много времени для отбора действительно полезных работ и их склейки на полях личных заметок.\nВ этом цикле статей буду пытаться разобрать, как в теории устроен протокол Kerberos и какие атаки с его использованием можно осуществить на практике в Active Directory. Также будут приведены некоторые рекомендации по противодействию рассматриваемым атакам.\nВ первой части будет рассмотрено устройство Kerberos в общем случае, а также реализация Kerberos в Active Directory.\n К материалу не стоит относится как к истине в последней инстанции. Только дураки не сомневаются.\n Экскурс. Краткий и исторический Протокол Kerberos был разработан в MIT, как часть научно-исследовательского проекта Афина, предназначенного для создания распределенной образовательной среды. К 1988 году проект достиг поставленных целей. В частности, было опубликовано описание протокола Kerberos v4, являющегося основой системы единого входа в разработанную среду. Предыдущие версии 1-3 были ранними прототипами и не использовались за пределами MIT.\nВ 1989 году состоялся официальный релиз Kerberos v4.\nОднако протоколу было куда развиваться. Например, можно выделить следующие недостатки Kerberos v4:\n Использование слабых криптографических алгоритмов. Уязвимости в архитектуре протокола, позволяющие проводить ряд атак методом оффлайн-перебора в отношение паролей пользователей. Отсутствие возможности делегирования учетных данных или использования дополнительных факторов аутентификации.  C целью устранения приведенных недостатков в 1993 году вышел новый протокол Kerberos v5.\nВ 1999 году Microsoft объявила о поддержке Kerberos v5 в своей будущей операционной системе Windows 2000, что было впоследствии реализовано в качестве соответствующего компонента Active Directory. До этого для аутентификации в рабочих группах на базе операционной системы Windows использовался протокол NT LAN Manager (NTLM), одна из версий которого (NTLM v2) применяется для локальной аутентификации в современных системах до сих пор. Подробное рассмотрение протокола NTLM v2 выходит за рамки статьи. Важно отметить, что указанный протокол также обладает рядом недостатков, которые было решено избежать при внедрении Kerberos v5 в Windows 2000.\nВ настоящее время Kerberos v5 можно считать довольно возрастным протоколом, тем не менее он используется во множестве различных систем, а не только в Active Directory. Вот неполный перечень:\n Amazon Web Services Apple macOS Google Cloud Microsoft Azure Oracle Solaris Red Hat Linux   Всюду далее речь будет идти именно о Kerberos v5. Для читаемости Kerberos v5 будет называться просто Kerberos.\n Требования к протоколу Kerberos Разобраться с принципом работы протокола Kerberos поначалу не просто. Постоянно приходится перечитывать ранее изученный материал и держать в голове множество деталей. Периодически возникает вопрос: почему все так сложно устроено?\nЧтобы корректно ответить на заданный вопрос и, что не менее важно, понять ответ, требуется обладать познаниями в устройстве криптографических протоколов, а также смежных дисциплинах. Полагаю, что копать настолько глубоко смысла нет. Все же чтобы понимать, чем обусловлены навороты Kerberos приведу ряд требований, которым протокол должен был отвечать:\n  Подразумевается, что обмен сообщений осуществляется с доверенных устройств, но в открытой недоверенной среде. Сетевой трафик может быть прослушан злоумышленником, а передаваемые сообщения могут быть подменены или перенаправлены. Таким образом секреты участников протокола ни при каких условиях не должны передаваться по сети в открытом виде.\n Любопытный факт: Kerberos разрабатывался до появления SSL.\n   Информация о пользователях и их секретах должна хранится в выделенном месте. Это ограничение обусловлено следующими соображениями:\n Необходимо минимизировать количество критических объектов, которые требуется защищать. Добавление нового, удаление старого, изменение текущего секрета у клиента или сервиса не должно требовать уведомления всех остальных участников протокола. Думаю, полезной будет следующая иллюстрация:    \r\r\rВарианты сетей без и c выделенным доверенным центром\r\r\r Должна поддерживаться технология единого входа (Single Sign-On). Это ограничение обусловлено тем, что пользователю неудобно каждый раз при обращении к ресурсу заново вводить пароль. Успешное окончание работы протокола должно означать успешную взаимную аутентификацию сторон. В результате работы протокола между клиентом и сервисом должен быть сформирован секретный сессионный ключ. Знание сессионного ключа позволяет злоумышленнику расшифровать некоторые старые сообщения, но организовать новую сессию с использованием уже известного сессионного ключа не получится.  Список терминов Прежде чем приступить к технической части определимся с терминологией, чтобы в дальнейшем избежать путаницы.\nKerberos – в первую очередь протокол аутентификации, но при этом предусматривающий возможность транспортировки информации необходимой для авторизации.\nВажно не путать:\n Аутентификация – процесс проверки подлинности. То есть проверка того, что пользователь, пытающийся получить доступ к системе именно тот, за кого себя выдает. Авторизация – процесс проверки прав доступа. Авторизация может быть применена только к аутентифицированному пользователю, так как перед тем, как проверять права доступа, необходимо выяснить личность объекта, которому указанные права планируется предоставить.\n Сервер – сетевой объект, обеспечивающий функционирование одного или нескольких сервисов. Примеры серверов: файловый сервер, почтовый сервер.\nКлиент – объект, обращающийся к сервису с целью получения доступа к ресурсам. Примеры клиентов: учетная запись или рабочая станция пользователя.\nОбласть действия (Realm) – совокупность клиентов, серверов и сервисов, участвующих в протоколе Kerberos.\nПринципал (Principal) – это строка, полностью идентифицирующая участника протокола Kerberos.\nПринципал может быть именем сервиса (Service Principal Name), или именем клиента (User Principal Name). Форматы принципалов для клиентов и сервисов различаются.\nПринципал клиента имеет следующую форму: principal-name[/instance-name]@REALM Пример: имя пользователя - Ivan, а область действия - DOMAIN.LOCAL, то полный принципал будет Ivan@DOMAIN.LOCAL.\nРасширение instance-name является опциональным и позволяет любому пользователю иметь более одного принципала. Так, если Ivan является администратором области DOMAIN.LOCAL, имя принципала будет Ivan/admin@DOMAIN.LOCAL, и у этого принципала будут другие права (и удостоверяющие данные).\nПринципал сервиса имеет следующую форму: service-name/host[:port]@REALM, где\n service-name – это специфичная для приложения строка, идентифицирующая сервис на этом хосте. host – это доменное имя хоста, на котором работает сервис port - порт на котором запущена служба.  Пример: для сервиса ftp, работающего на хосте с именем fileserver.example.com в области @EXAMPLE.COM, имя принципала сервиса будет ftp/fileserver.example.com@EXAMPLE.COM.\nПочему такое внимание уделяется этим именам? В дальнейшем будет понятнее, но уже сейчас можно отметить, что в Kerberos для идентификации сервера требуется именно принципал (имя), тогда как в NTLM может использоваться IP-адрес.\n Примечание: возможность использования IP-адресов была добавлена в новых клиентах Windows.\n Рассмотрим пример: есть рабочая станция (DNS-имя: station.domain.local, IP-адрес: 192.168.10.12) с общедоступной сетевой папкой scan. При открытии проводника и переходу по UNC-пути \\\\station.domain.local\\scan будет использоваться Kerberos, но при указании UNC-пути \\\\192.168.10.12\\scan будет использоваться NTLM, так как принципал отсутствует. В частности, поэтому администраторы не любят отключать NTLM, так как устаревшее сетевое оборудование (принтеры, роутеры и пр.) может быть настроено со статическими IP-адресами или вовсе не поддерживать Kerberos.\nЦентр распределения ключей (Key Distribution Center, далее – KDC) является доверенным центром аутентификации для всех участников протокола Kerberos в рамках определенной области действия.\nKDC включает в себя следующие компоненты:\n База данных Kerberos, предназначенная для хранения информации о всех принципалах и их секретах. Сервер аутентификации (Authentication Server, AS), обрабатывающий запросы на аутентификацию клиентов к области действия протокола Kerberos; Сервер выдачи разрешений (Ticket Granting Server, TGS), обрабатывающий запросы на аутентификацию к определенному сервису, функционирующего в составе указанной области действия.  Проиллюстрируем вышесказанное следующей зарисовкой:\n\r\r\rУчастники протокола Kerberos\r\r\rАутентификация с использованием Kerberos \r\r\rИллюстрация порядка изложения материала\r\r\rНачнем от общего и перейдем к частному.\nЖитейская аналогия Рассмотрим немного выдуманную, но полезную для последующих аналогий ситуацию. Представим парк развлечений. Допустим, что перечень разрешенных посетителей парка содержится в специальной базе данных. Для тех, кто в базе отсутствует проход воспрещен. Как организовано посещение парка:\n Посетитель приходит на вход и показывает охраннику свой паспорт. Охранник проверяет наличие посетителя в базе данных. Охранник выдает посетителю суточный билет на посещение парка. Посетитель выбирает понравившийся ему аттракцион и идет на кассу, чтобы получить билет. На кассе проверяют суточный билет посетителя и выдают билет на аттракцион. Посетитель идет на выбранный аттракцион и показывает смотрителю аттракциона, полученный на кассе билет. Смотритель проверяет билет и пропускает посетителя. Посетитель при желании может посмотреть бейджик смотрителя, чтобы убедиться, что он действительно сотрудник парка.  Если посетитель захотел пойти на другой аттракцион, он снова идет на кассу и показывает суточный билет. Далее повторяется процесс из шагов 5, 6, 7 только с другим смотрителем и другим аттракционом.\nПо верхам в общем виде Теперь по аналогии рассмотрим упрощенную схему аутентификации с использованием Kerberos:\n\r\r\rОбщая схема обмена запросами в Kerberos\r\r\r Клиент отправляет запрос на аутентификацию к области действия. Сервер аутентификации проверяет подлинность Клиента с использованием Базы данных Kerberos. Сервер выдает Клиенту разрешение (пока просто назовем его TGT) на получение отдельных разрешений (далее – ST), требующимся для доступа к сервисам, входящим в область действия. С использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису А («ST для А»). Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису А. Клиент с использованием «ST для А» запрашивает у Сервиса А доступ к его ресурсам. Сервис А проверяет «ST для А» и предоставляет Клиенту доступ к своим ресурсам. При необходимости сервис также проходит аутентификацию перед клиентом.  В дальнейшем при необходимости доступа к другому сервису:\nС использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису Б («ST для Б»). Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису Б. Клиент с использованием «ST для Б» запрашивает у Сервиса Б доступ к его ресурсам. Сервис Б проверяет «ST для Б» и предоставляет Клиенту доступ к своим ресурсам.  Видно, что стороны обмениваются сообщениями, содержащими запросы и ответы с разрешениями. Официально форматы указанных сообщений задокументированы в RFC 4120.\nТеперь переназовем передаваемые сообщения в соответствие с RFC:\n Запрос на аутентификацию к области действия (шаг 1) - сообщение KRB_AS_REQ. Ответ сервера на запрос аутентификации клиента (шаг 3) – сообщение KRB_AS_REP. Разрешение на получение разрешений – TGT (Ticket Granting Ticket).  Другие встречающиеся в литературе названия: мандат / билет на получение разрешений, первичное удостоверение пользователя.\n Примечание: в различных источниках часто встречается словосочетание «TGT билет», но в аббревиатуре TGT уже заложено слово «билет» - Ticket Granting Ticket, поэтому правильнее говорить просто «TGT».\n   Запрос на доступ к сервису (шаг 4) – сообщение KRB_TGS_REQ.\n  Ответ сервера выдачи разрешений (шаг 5) – сообщение KRB_TGS_REP.\n  Разрешение на доступ к сервису – ST (Service Ticket) Другие встречающиеся названия: TGS билет, билет сервиса, мандат сервиса.\n  Запрос клиента на аутентификацию к сервису (шаг 6) – сообщение KRB_AP_REQ.\n  Опциональный ответ с аутентификацией сервиса перед клиентом (шаг 7) – сообщение KRB_AP_REP.\n  Чтобы проще было запомнить:\n KRB ~ KeRBeros AS ~ Authentication Server REP ~ REsPonse REQ ~ REQuest AP ~ APplication server  Далее каждый запрос будет разобран подробнее.\nРазбор аутентификации в Kerberos согласно RFC В начале имеются три участника протокола Kerberos:\n Клиент Сервис Центр распределения ключей  Каждый из участников обладает своим долговременным секретом (ключом). Кроме того, центр распределения ключей обладает секретами всех участников.\n\r\r\rРис. 3 - Первоначальное распределение секретов\r\r\rАлгоритм формирования ключа Ключ формируется как результат работы хэш-функции под названием string2key. Хэш может вычисляться разными способами в зависимости от соответствующих настроек Kerberos, в частности поддерживаются следующие алгоритмы:\n   Название алгоритма (etype) Способ вычисления ключа     RC4_HMAC_MD5 NT-хэш пароля участника   AES128_CTS_HMAC_SHA1_96 PBKDF2(пароль, соль*, kvno**, 128)   AES256_CTS_HMAC_SHA1_96 PBKDF2(пароль, соль*, kvno**, 256)    В последних версиях Windows по умолчанию используется шифрование AES. Но для совместимости с системами ниже Windows Vista и Windows 2008 Server необходима поддержка алгоритма RC4.\nСоль формируется следующим образом:\n  Для доменных пользователей: полностью определенное имя домена заглавными буквами (FQDN) + регистр зависимое имя пользователя.\n Пример: DOMAIN.LOCALuser\n   Для компьютеров: FQDN + host + регистр зависимое имя компьютера без $ в конце.\n Пример: DOMAIN.LOCALhostcomputer.domain.local\n   kvno - key version number (в переводе - номер версии ключа). kvno представляет собой счетчик, увеличивающий значение каждый раз при смене пароля.\nТаким образом, у одного и того же пользователя в разных доменах или для разных учетных записей будут разные секреты (хэши паролей), даже если пароль одинаковый. То есть строить радужные таблицы для указанных хэшей нецелесообразно.\nИсточники:\n Kerberos from Hacker recipes A Note on Calculating Kerberos Keys for AD Accounts (snovvcrash)  KRB_AS_REQ \rКлиент отправляет серверу аутентификации запрос, содержащий:\n Принципал клиента Срок жизни билета   Примечание: если это не первый материал по Kerberos, который вы читаете и возникает вопрос, почему отсутствует предварительная аутентификации, то поясню – это дополнительная настройка протокола, которая в «классической» реализации по умолчанию отключена. В реализации Kerberos для Active Directory, указанная настройка напротив по умолчанию активна и этот случай будет рассмотрен чуть позже.\n KRB_AS_REP \rСервер аутентификации по полученному принципалу находит в базе Kerberos секрет клиента. Кроме того, для дальнейшего общения с KDC сервер аутентификации случайным образом генерирует сессионный ключ. В итоге в ответ клиенту отправляются два сообщения.\nПервое сообщение зашифровано с использованием секрета клиента и содержит:\n Сессионный ключ для KDC Метка времени Срок жизни TGT  Второе сообщение (TGT) зашифровано уже с использованием (!) секрета KDC и включает в себя те же самые данные, что и первое сообщение, но вместе с принципалом клиента.\n Примечание: время жизни TGT определяется, как наименьшее время среди запрошенного клиентом и хранящегося в настройках центра распределения ключей.\n Клиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с KDC. TGT также сохраняется у клиента в зашифрованном виде.\nKRB_TGS_REQ \rТеперь, пройдя аутентификацию, клиент желает получить доступ к какому-то сервису. Для этого он отправляет серверу выдачи разрешений запрос, содержащий:\n Принципал сервиса Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с KDC. Сохраненный TGT  Приняв запрос, сервер выдачи разрешений прежде всего выполняет проверку полученных данных. Сначала с использованием секрета KDC сервер расшифровывает TGT (1) и по метке времени со сроком действия убеждается, что TGT не протух (2).\nДалее сервер извлекает сессионный ключ для KDC. Несмотря на то, что указанный ключ был создан в KDC, нужды хранить его в базе Kerberos нет. Действительно, TGT не может быть изменен кем-либо кроме KDC, поэтому полученным из него данным можно доверять.\nВозникает важный вопрос - почему можно быть уверенным, что TGT не отправлен злоумышленником, перехватившим его при прослушивании сетевого трафика? Для этого в запросе прилагается аутентификатор. Аутентификатор зашифрован с использованием сессионного ключа KDC, который мог быть извлечен из KRB_AS_REP запроса только определенным клиентом. Метка времени добавляется с целью предотвращения атак методом повтора, чтобы злоумышленник не смог вставить в свой запрос старый аутентификатор клиента, перехваченный из прошлых сообщений.\nСервер выдачи разрешений сравнивает принципалы пользователя из TGT и аутентификатора, а также убеждается, что аутентификатор был сформирован не более двух минут назад.\nKRB_TGS_REP \rВ случае успешного завершения проверок сервер выдачи разрешений отправляет клиенту ответ, содержащий два сообщения. Первое сообщение зашифровано с использованием сессионного ключа для KDC и содержит:\n Сессионный ключ для общения с сервисом Метка времени Срок жизни TGS билета Принципал сервиса  Второе сообщение (TGS билет) зашифровано с использованием секрета сервиса и включает в себя те же самые данные, что и первое сообщение, а также принципал клиента.\nКлиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с сервисом. TGS билет сохраняется у клиента в зашифрованном виде.\nKRB_AP_REQ \rКлиент отправляет сервису запрос на получение доступа, содержащий:\n Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с сервисом. Сохраненный TGS билет Флаг взаимной аутентификации  Приняв запрос, сервис прежде всего выполняет проверку полученных данных. Сначала с использованием своего секрета сервис расшифровывает TGS (1) и по метке времени со сроком действия убеждается, что TGS не протух (2). Далее сервис извлекает сессионный ключ.\nTGS билет не может быть изменен кем-либо кроме того, кто знает секрет сервиса, а это KDC и сам сервис. Сервис доверяет KDC, таким образом извлеченным из TGS билета данным сервис также может доверять.\nАналогично KRB_TGS_REQ расшифровывается аутентификатор и выполняются другие проверки. Обратите внимание, что сервис удостоверяется в подлинности клиента, не обращаясь к KDC.\nKRB_AP_REP \rОпционально, в случае если активен флаг взаимной аутентификации, сервис также подтверждает перед клиентом свою подлинность, отправив ответ с меткой времени, зашифрованной с использованием сессионного ключа.\nKerberos в Active Directory «Чтобы донести идею её надо рассказать три раза, но разными словами» (с)\nРассмотрим реализацию Kerberos в Active Directory. Уточним терминологию, теперь:\nОбласть действия – домен.\nЦентр распределения ключей – контроллер домена.\nСервер аутентификации и сервер выдачи разрешений – оба объединены в рамках одного компонента, функционирующего на контроллере домена.\nБаза данных Kerberos – в Active Directory информация о секретах пользователей хранится на контроллерах домена в файле ntds.dit.\nkrbtgt – название учетной записи, по умолчанию создаваемой вместе с доменом и обладающей секретом контроллера домена.\nВ итоге с учетом переименований получается следующая структура:\n\rВ целом в Active Directory Kerberos работает согласно RFC, но есть ряд особенностей. Рассмотрим указанные особенности на следующем примере.\nДоменная аутентификация пользователя к рабочей станции в Active Directory Изначально на рабочей станции активно следующее диалоговое окно:\n\rПользователь вводит свои учетные данные (название домена, имя учетной записи, пароль) и жмет «OK». Далее компонент, ответственный за отображение диалогового окна, передает запрос на аутентификацию пользователя с использованием введенных данных в локальный центр безопасности (Local Security Authority, LSA). Центр содержит различные динамические библиотеки, предоставляющие функции для процедур аутентификации, смены паролей, а также выдачи токенов. Указанные библиотеки вызываются и работают в контексте процесса lsass.exe (Local Security Authority Subsystem Service).\nВ зависимости от запроса для его обработки согласовывается соответствующая библиотека. Примеры библиотек и протоколов:\n msv1_0.dll (NTLM) kerberos.dll (Kerberos) SChannel.dll (TLS/SSL) WDigest.dll (digest аутентификация)  По умолчанию для обработки запросов на проверку подлинности пользователя при входе в домен выбирается библиотека kerberos.dll, реализующая одноименный протокол.\nСледует понимать, что пользователь никогда напрямую не взаимодействует с системой. Система олицетворяет пользователя и получает доступ к необходимым ресурсам с использованием прав доступа, которыми указанный пользователь обладает. Таким образом систему в ходе аутентификации можно рассматривать как сервис.\nВ итоге имеем следующую картину:\n\rСекрет системы (ключ) присваивается рабочей станции при ее добавлении в домен. Важно отметить, что введенный пользователем пароль не хранится в памяти рабочей станции. Ключ пользователя формируется при помощи ранее рассмотренной хэш-функции string2key.\nДалее процесс, обеспечивающий аутентификацию пользователя, обращается к контроллеру домена с использованием сформированного ключа. Здесь проявляется одна из особенностей реализации Kerberos в Active Directory – предварительная аутентификация по умолчанию включена.\nKRB_AS_REQ с предварительной аутентификацией \rВ этом случае клиент отправляет серверу аутентификации запрос, содержащий:\n Принципал клиента Метку времени, зашифрованную с использованием секрета клиента  Получив запрос, контроллер домена с помощью секрета клиента расшифровывает метку времени и сравнивает её с текущим значением. Если переданное время расходится с текущим меньше чем на пять минут, то значит предварительная аутентификация клиента успешно пройдена. В противном случае контроллер отправляет сообщение об ошибке.\nKRB_AS_REP (AD) В случае успешного прохождения предварительной аутентификации контроллер домена отправляет рабочей станции ответ, аналогичный рассмотренному в разделе про RFC.\n\rВ ответе появилась еще одна особенность, а именно новое поле «PAC» в содержимом TGT.\nPAC (Privilege Attribute Certificate) это данные, предназначенные для авторизации пользователя. Ранее уже отмечалось, что кроме аутентификации Kerberos может использоваться при авторизации, но не пояснялось как. Поле PAC изначально было предусмотрено в RFC без конкретного описания содержимого. Какая информация передается в PAC и как она обрабатывается зависит от конкретной реализации Kerberos.\nВ Active Directory PAC среди прочего содержит следующую информацию:\n Идентификатор безопасности (SID) учетной записи пользователя Идентификаторы групп, в которых состоит пользователь  Указанная информация дважды подписывается. Одна подпись принадлежит krbtgt, а вторая сервису, к которому обращался клиент (в случае KRB_AS_REP тоже krbtgt).\nKRB_TGS_REQ (AD) Запрос производится аналогично рассмотренному ранее в RFC.\n\rKRB_TGS_REP (AD) PAC из TGT, полученный в предыдущем сообщении, помещается в TGS билет. В этот раз PAC подписывается не только с использованием секрета krbtgt, но и секрета системы.\n\rLOGON С использованием сессионного ключа LSA извлекает подписанный PAC из TGS билета. LSA проверяет подпись PAC при помощи секрета системы и далее с учетом добытых из PAC доменных групп безопасности формирует процесс Winlogon c соответствующим токеном доступа клиента.\n\rОпционально система может запросить контроллер домена выполнить дополнительную проверку подписи с PAC с помощью секрета krbtgt.\nИтог Думаю, для поверхностного знакомства с Kerberos достаточно. Несмотря на то, что многие моменты остались за скобками, представленного материала в целом хватает для понимания атак на протокол Kerberos, которые рассмотрим в следующей части.\nСсылки на используемые источники  Kerberos Protocol Tutorial (Fulvio Ricciardi) Kerberos and Windows Security Series (Robert Broeckelmann) Статья с pro-ldap.ru Блог Pixis Фундаментальная статья c tarlogic.com (Eloy Pérez) Документация Microsoft How to Kerberos? its components and function (Sheeraz Ali) Windows authentication attacks part 2 – kerberos (Ahmed Sultan)  Картинка для обложки взята отсюда.\n","wordCount":"3307","inLanguage":"ru","image":"https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo.jpg","datePublished":"2022-08-05T11:30:03Z","dateModified":"2022-08-05T11:30:03Z","author":{"@type":"Person","name":"Ardent101"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ardent101.github.io/posts/kerberos_theory/"},"publisher":{"@type":"Organization","name":"Ardent101","logo":{"@type":"ImageObject","url":"https://ardent101.github.io/static/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ardent101.github.io/ accesskey=h title="Главная (Alt + H)"><img src=https://ardent101.github.io/apple-touch-icon.png alt=logo aria-label=logo height=35>Главная</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ardent101.github.io/archives/ title=Архив><span>Архив</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория</h1><div class=post-meta><span title="2022-08-05 11:30:03 +0000 +0000">августа 5, 2022</span>&nbsp;·&nbsp;16 мин&nbsp;·&nbsp;Ardent101</div></header><figure class=entry-cover><img loading=lazy srcset="https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo_hua4db37e4202b5d67cfa4a8f227b1d872_184315_360x0_resize_q75_box.jpg 360w ,https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo_hua4db37e4202b5d67cfa4a8f227b1d872_184315_480x0_resize_q75_box.jpg 480w ,https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo_hua4db37e4202b5d67cfa4a8f227b1d872_184315_720x0_resize_q75_box.jpg 720w ,https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo_hua4db37e4202b5d67cfa4a8f227b1d872_184315_1080x0_resize_q75_box.jpg 1080w ,https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo.jpg 1080w" sizes="(min-width: 768px) 720px, 100vw" src=https://ardent101.github.io/posts/kerberos_theory/images/Kerberos_logo.jpg alt width=1080 height=1080></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Оглавление</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#вступление>Вступление</a></li><li><a href=#экскурс-краткий-и-исторический>Экскурс. Краткий и исторический</a></li><li><a href=#требования-к-протоколу-kerberos>Требования к протоколу Kerberos</a></li><li><a href=#список-терминов>Список терминов</a></li><li><a href=#аутентификация-с-использованием-kerberos>Аутентификация с использованием Kerberos</a><ul><li><a href=#житейская-аналогия>Житейская аналогия</a></li><li><a href=#по-верхам-в-общем-виде>По верхам в общем виде</a></li></ul></li><li><a href=#разбор-аутентификации-в-kerberos-согласно-rfc>Разбор аутентификации в Kerberos согласно RFC</a><ul><li><a href=#алгоритм-формирования-ключа>Алгоритм формирования ключа</a></li><li><a href=#krb_as_req>KRB_AS_REQ</a></li><li><a href=#krb_as_rep>KRB_AS_REP</a></li><li><a href=#krb_tgs_req>KRB_TGS_REQ</a></li><li><a href=#krb_tgs_rep>KRB_TGS_REP</a></li><li><a href=#krb_ap_req>KRB_AP_REQ</a></li><li><a href=#krb_ap_rep>KRB_AP_REP</a></li></ul></li><li><a href=#kerberos-в-active-directory>Kerberos в Active Directory</a><ul><li><a href=#доменная-аутентификация-пользователя-к-рабочей-станции-в-active-directory>Доменная аутентификация пользователя к рабочей станции в Active Directory</a></li><li><a href=#krb_as_req-с-предварительной-аутентификацией>KRB_AS_REQ с предварительной аутентификацией</a></li><li><a href=#krb_as_rep-ad>KRB_AS_REP (AD)</a></li><li><a href=#krb_tgs_req-ad>KRB_TGS_REQ (AD)</a></li><li><a href=#krb_tgs_rep-ad>KRB_TGS_REP (AD)</a></li><li><a href=#logon>LOGON</a></li></ul></li><li><a href=#итог>Итог</a><ul><li><a href=#ссылки-на-используемые-источники>Ссылки на используемые источники</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=вступление>Вступление<a hidden class=anchor aria-hidden=true href=#вступление>#</a></h2><p>На мой взгляд специалисту по тестированию на проникновение инфраструктуры на базе Active Directory важно понимать общее устройство протокола Kerberos. Вот лишь несколько причин почему:</p><ul><li>Знание устройства протокола Kerberos необходимо для понимания ряда классических атак.</li><li>Периодически появляются новые атаки, но прежде чем приступать к их эксплуатации, необходимо разобраться к каким последствиям они могут привести. Без знания Kerberos это порой затруднительно, либо вовсе невозможно.</li><li>Личная чуйка, что если человек называет себя специалистом, то он должен обладать несколько более глубокими знаниями, чем название инструмента или кнопки, на которую надо нажать.</li></ul><p>Про Kerberos и атаки на него уже написано немало статей. Многие из указанных статей предназначены либо для математиков, либо для сетевых инженеров, либо для специалистов по тестированию на проникновение. Материал часто преподносится однобоко в разрозненной форме и приходится тратить много времени для отбора действительно полезных работ и их склейки на полях личных заметок.</p><p>В этом цикле статей буду пытаться разобрать, как в теории устроен протокол Kerberos и какие атаки с его использованием можно осуществить на практике в Active Directory. Также будут приведены некоторые рекомендации по противодействию рассматриваемым атакам.</p><p>В первой части будет рассмотрено устройство Kerberos в общем случае, а также реализация Kerberos в Active Directory.</p><blockquote><p>К материалу не стоит относится как к истине в последней инстанции. Только дураки не сомневаются.</p></blockquote><h2 id=экскурс-краткий-и-исторический>Экскурс. Краткий и исторический<a hidden class=anchor aria-hidden=true href=#экскурс-краткий-и-исторический>#</a></h2><p>Протокол Kerberos был разработан в MIT, как часть научно-исследовательского проекта Афина, предназначенного для создания распределенной образовательной среды. К 1988 году проект достиг поставленных целей. В частности, было опубликовано описание протокола Kerberos v4, являющегося основой системы единого входа в разработанную среду. Предыдущие версии 1-3 были ранними прототипами и не использовались за пределами MIT.</p><p>В 1989 году состоялся официальный релиз Kerberos v4.</p><p>Однако протоколу было куда развиваться. Например, можно выделить следующие недостатки Kerberos v4:</p><ul><li>Использование слабых криптографических алгоритмов.</li><li>Уязвимости в архитектуре протокола, позволяющие проводить ряд атак методом оффлайн-перебора в отношение паролей пользователей.</li><li>Отсутствие возможности делегирования учетных данных или использования дополнительных факторов аутентификации.</li></ul><p>C целью устранения приведенных недостатков в 1993 году вышел новый протокол Kerberos v5.</p><p>В 1999 году Microsoft объявила о поддержке Kerberos v5 в своей будущей операционной системе Windows 2000, что было впоследствии реализовано в качестве соответствующего компонента Active Directory. До этого для аутентификации в рабочих группах на базе операционной системы Windows использовался протокол NT LAN Manager (NTLM), одна из версий которого (NTLM v2) применяется для локальной аутентификации в современных системах до сих пор. Подробное рассмотрение протокола NTLM v2 выходит за рамки статьи. Важно отметить, что указанный протокол также обладает рядом недостатков, которые было решено избежать при внедрении Kerberos v5 в Windows 2000.</p><p>В настоящее время Kerberos v5 можно считать довольно возрастным протоколом, тем не менее он используется во множестве различных систем, а не только в Active Directory. Вот неполный перечень:</p><ul><li>Amazon Web Services</li><li>Apple macOS</li><li>Google Cloud</li><li>Microsoft Azure</li><li>Oracle Solaris</li><li>Red Hat Linux</li></ul><blockquote><p>Всюду далее речь будет идти именно о Kerberos v5. Для читаемости Kerberos v5 будет называться просто Kerberos.</p></blockquote><h2 id=требования-к-протоколу-kerberos>Требования к протоколу Kerberos<a hidden class=anchor aria-hidden=true href=#требования-к-протоколу-kerberos>#</a></h2><p>Разобраться с принципом работы протокола Kerberos поначалу не просто. Постоянно приходится перечитывать ранее изученный материал и держать в голове множество деталей. Периодически возникает вопрос: почему все так сложно устроено?</p><p>Чтобы корректно ответить на заданный вопрос и, что не менее важно, понять ответ, требуется обладать познаниями в устройстве криптографических протоколов, а также смежных дисциплинах. Полагаю, что копать настолько глубоко смысла нет. Все же чтобы понимать, чем обусловлены навороты Kerberos приведу ряд требований, которым протокол должен был отвечать:</p><ul><li><p>Подразумевается, что обмен сообщений осуществляется с доверенных устройств, но в открытой недоверенной среде. Сетевой трафик может быть прослушан злоумышленником, а передаваемые сообщения могут быть подменены или перенаправлены. Таким образом секреты участников протокола ни при каких условиях не должны передаваться по сети в открытом виде.</p><blockquote><p>Любопытный факт: Kerberos разрабатывался до появления SSL.</p></blockquote></li><li><p>Информация о пользователях и их секретах должна хранится в выделенном месте. Это ограничение обусловлено следующими соображениями:</p><ul><li>Необходимо минимизировать количество критических объектов, которые требуется защищать.</li><li>Добавление нового, удаление старого, изменение текущего секрета у клиента или сервиса не должно требовать уведомления всех остальных участников протокола. Думаю, полезной будет следующая иллюстрация:</li></ul></li></ul><p><figure><img src=images/Topology.png alt=topology><figcaption><p style=text-align:center>Варианты сетей без и c выделенным доверенным центром</p></figcaption></figure></p><ul><li>Должна поддерживаться технология единого входа (Single Sign-On). Это ограничение обусловлено тем, что пользователю неудобно каждый раз при обращении к ресурсу заново вводить пароль.</li><li>Успешное окончание работы протокола должно означать успешную взаимную аутентификацию сторон.</li><li>В результате работы протокола между клиентом и сервисом должен быть сформирован секретный сессионный ключ. Знание сессионного ключа позволяет злоумышленнику расшифровать некоторые старые сообщения, но организовать новую сессию с использованием уже известного сессионного ключа не получится.</li></ul><h2 id=список-терминов>Список терминов<a hidden class=anchor aria-hidden=true href=#список-терминов>#</a></h2><p>Прежде чем приступить к технической части определимся с терминологией, чтобы в дальнейшем избежать путаницы.</p><p><strong>Kerberos</strong> – в первую очередь протокол аутентификации, но при этом предусматривающий возможность транспортировки информации необходимой для авторизации.</p><p>Важно не путать:</p><blockquote><p><strong>Аутентификация</strong> – процесс проверки подлинности. То есть проверка того, что пользователь, пытающийся получить доступ к системе именно тот, за кого себя выдает.<br><strong>Авторизация</strong> – процесс проверки прав доступа. Авторизация может быть применена только к аутентифицированному пользователю, так как перед тем, как проверять права доступа, необходимо выяснить личность объекта, которому указанные права планируется предоставить.</p></blockquote><p><strong>Сервер</strong> – сетевой объект, обеспечивающий функционирование одного или нескольких сервисов. Примеры серверов: файловый сервер, почтовый сервер.</p><p><strong>Клиент</strong> – объект, обращающийся к сервису с целью получения доступа к ресурсам. Примеры клиентов: учетная запись или рабочая станция пользователя.</p><p><strong>Область действия</strong> (<em>Realm</em>) – совокупность клиентов, серверов и сервисов, участвующих в протоколе Kerberos.</p><p><strong>Принципал</strong> (<em>Principal</em>) – это строка, полностью идентифицирующая участника протокола Kerberos.</p><p>Принципал может быть именем сервиса (<em>Service Principal Name</em>), или именем клиента (<em>User Principal Name</em>). Форматы принципалов для клиентов и сервисов различаются.</p><p>Принципал клиента имеет следующую форму: <em>principal-name[/instance-name]@REALM</em>
Пример: имя пользователя - <em>Ivan</em>, а область действия - <em>DOMAIN.LOCAL</em>, то полный принципал будет <em>Ivan@DOMAIN.LOCAL</em>.</p><p>Расширение <em>instance-name</em> является опциональным и позволяет любому пользователю иметь более одного принципала. Так, если <em>Ivan</em> является администратором области <em>DOMAIN.LOCAL</em>, имя принципала будет <em>Ivan/admin@DOMAIN.LOCAL</em>, и у этого принципала будут другие права (и удостоверяющие данные).</p><p><a href=https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spn-setspn-syntax.aspx>Принципал сервиса</a> имеет следующую форму:
<em>service-name/host[:port]@REALM</em>, где</p><ul><li><em>service-name</em> – это специфичная для приложения строка, идентифицирующая сервис на этом хосте.</li><li><em>host</em> – это доменное имя хоста, на котором работает сервис</li><li><em>port</em> - порт на котором запущена служба.</li></ul><p>Пример: для сервиса <em>ftp</em>, работающего на хосте с именем <em>fileserver.example.com</em> в области <em>@EXAMPLE.COM</em>, имя принципала сервиса будет <em>ftp/fileserver.example.com@EXAMPLE.COM</em>.</p><p>Почему такое внимание уделяется этим именам? В дальнейшем будет понятнее, но уже сейчас можно отметить, что в Kerberos для идентификации сервера требуется именно принципал (имя), тогда как в NTLM может использоваться IP-адрес.</p><blockquote><p>Примечание: возможность использования IP-адресов была <a href=https://learn.microsoft.com/en-us/windows-server/security/kerberos/configuring-kerberos-over-ip>добавлена</a> в новых клиентах Windows.</p></blockquote><p>Рассмотрим пример: есть рабочая станция (DNS-имя: <em>station.domain.local</em>,
IP-адрес: 192.168.10.12) с общедоступной сетевой папкой <em>scan</em>. При открытии проводника и переходу по UNC-пути <em>\\station.domain.local\scan</em> будет использоваться Kerberos, но при указании UNC-пути <em>\\192.168.10.12\scan</em> будет использоваться NTLM, так как принципал отсутствует. В частности, поэтому администраторы не любят отключать NTLM, так как устаревшее сетевое оборудование (принтеры, роутеры и пр.) может быть настроено со статическими IP-адресами или вовсе не поддерживать Kerberos.</p><p><strong>Центр распределения ключей</strong> (<em>Key Distribution Center</em>, далее – KDC) является доверенным центром аутентификации для всех участников протокола Kerberos в рамках определенной области действия.</p><p>KDC включает в себя следующие компоненты:</p><ul><li><strong>База данных Kerberos</strong>, предназначенная для хранения информации о всех принципалах и их секретах.</li><li><strong>Сервер аутентификации</strong> (<em>Authentication Server, AS</em>), обрабатывающий запросы на аутентификацию клиентов к области действия протокола Kerberos;</li><li><strong>Сервер выдачи разрешений</strong> (<em>Ticket Granting Server, TGS</em>), обрабатывающий запросы на аутентификацию к определенному сервису, функционирующего в составе указанной области действия.</li></ul><p>Проиллюстрируем вышесказанное следующей зарисовкой:</p><p><figure><img src=images/realm_high.png alt=realm_members><figcaption><p style=text-align:center>Участники протокола Kerberos</p></figcaption></figure></p><h2 id=аутентификация-с-использованием-kerberos>Аутентификация с использованием Kerberos<a hidden class=anchor aria-hidden=true href=#аутентификация-с-использованием-kerberos>#</a></h2><p><figure><img src=images/matreshki.png alt=matreshki><figcaption><p style=text-align:center>Иллюстрация порядка изложения материала</p></figcaption></figure></p><p>Начнем от общего и перейдем к частному.</p><h3 id=житейская-аналогия>Житейская аналогия<a hidden class=anchor aria-hidden=true href=#житейская-аналогия>#</a></h3><p>Рассмотрим немного выдуманную, но полезную для последующих аналогий ситуацию. Представим парк развлечений. Допустим, что перечень разрешенных посетителей парка содержится в специальной базе данных. Для тех, кто в базе отсутствует проход воспрещен. Как организовано посещение парка:</p><ol><li>Посетитель приходит на вход и показывает охраннику свой паспорт.</li><li>Охранник проверяет наличие посетителя в базе данных.</li><li>Охранник выдает посетителю суточный билет на посещение парка.</li><li>Посетитель выбирает понравившийся ему аттракцион и идет на кассу, чтобы получить билет.</li><li>На кассе проверяют суточный билет посетителя и выдают билет на аттракцион.</li><li>Посетитель идет на выбранный аттракцион и показывает смотрителю аттракциона, полученный на кассе билет.</li><li>Смотритель проверяет билет и пропускает посетителя.</li><li>Посетитель при желании может посмотреть бейджик смотрителя, чтобы убедиться, что он действительно сотрудник парка.</li></ol><p>Если посетитель захотел пойти на другой аттракцион, он снова идет на кассу и показывает суточный билет. Далее повторяется процесс из шагов 5, 6, 7 только с другим смотрителем и другим аттракционом.</p><h3 id=по-верхам-в-общем-виде>По верхам в общем виде<a hidden class=anchor aria-hidden=true href=#по-верхам-в-общем-виде>#</a></h3><p>Теперь по аналогии рассмотрим упрощенную схему аутентификации с использованием Kerberos:</p><p><figure><img src=images/Kerberos_general_scheme_design.png alt=scheme><figcaption><p style=text-align:center>Общая схема обмена запросами в Kerberos</p></figcaption></figure></p><ol><li>Клиент отправляет запрос на аутентификацию к области действия.</li><li>Сервер аутентификации проверяет подлинность Клиента с использованием Базы данных Kerberos.</li><li>Сервер выдает Клиенту разрешение (пока просто назовем его TGT) на получение отдельных разрешений (далее – ST), требующимся для доступа к сервисам, входящим в область действия.</li><li>С использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису А («ST для А»).</li><li>Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису А.</li><li>Клиент с использованием «ST для А» запрашивает у Сервиса А доступ к его ресурсам.</li><li>Сервис А проверяет «ST для А» и предоставляет Клиенту доступ к своим ресурсам. При необходимости сервис также проходит аутентификацию перед клиентом.</li></ol><p>В дальнейшем при необходимости доступа к другому сервису:</p><ol start=8><li>С использованием полученного на шаге №3 разрешения (TGT) Клиент запрашивает разрешение на доступ к Сервису Б («ST для Б»).</li><li>Сервер выдачи разрешений проверяет TGT и выдает Клиенту ST для доступа к сервису Б.</li><li>Клиент с использованием «ST для Б» запрашивает у Сервиса Б доступ к его ресурсам.</li><li>Сервис Б проверяет «ST для Б» и предоставляет Клиенту доступ к своим ресурсам.</li></ol><p>Видно, что стороны обмениваются сообщениями, содержащими запросы и ответы с разрешениями. Официально форматы указанных сообщений задокументированы в RFC 4120.</p><p>Теперь переназовем передаваемые сообщения в соответствие с RFC:</p><ul><li>Запрос на аутентификацию к области действия (шаг 1) - сообщение <em>KRB_AS_REQ</em>.</li><li>Ответ сервера на запрос аутентификации клиента (шаг 3) – сообщение <em>KRB_AS_REP</em>.</li><li>Разрешение на получение разрешений – <em>TGT</em> (<em>Ticket Granting Ticket</em>).</li></ul><p>Другие встречающиеся в литературе названия: мандат / билет на получение разрешений, первичное удостоверение пользователя.</p><blockquote><p>Примечание: в различных источниках часто встречается словосочетание «TGT билет», но в аббревиатуре TGT уже заложено слово «билет» - Ticket Granting Ticket, поэтому правильнее говорить просто «TGT».</p></blockquote><ul><li><p>Запрос на доступ к сервису (шаг 4) – сообщение <em>KRB_TGS_REQ</em>.</p></li><li><p>Ответ сервера выдачи разрешений (шаг 5) – сообщение <em>KRB_TGS_REP</em>.</p></li><li><p>Разрешение на доступ к сервису – <em>ST</em> (<em>Service Ticket</em>)
Другие встречающиеся названия: TGS билет, билет сервиса, мандат сервиса.</p></li><li><p>Запрос клиента на аутентификацию к сервису (шаг 6) – сообщение <em>KRB_AP_REQ</em>.</p></li><li><p>Опциональный ответ с аутентификацией сервиса перед клиентом (шаг 7) – сообщение <em>KRB_AP_REP</em>.</p></li></ul><p>Чтобы проще было запомнить:</p><ul><li>KRB ~ <strong>K</strong>e<strong>RB</strong>eros</li><li>AS ~ <strong>A</strong>uthentication <strong>S</strong>erver</li><li>REP ~ <strong>RE</strong>s<strong>P</strong>onse</li><li>REQ ~ <strong>REQ</strong>uest</li><li>AP ~ <strong>AP</strong>plication server</li></ul><p>Далее каждый запрос будет разобран подробнее.</p><h2 id=разбор-аутентификации-в-kerberos-согласно-rfc>Разбор аутентификации в Kerberos согласно RFC<a hidden class=anchor aria-hidden=true href=#разбор-аутентификации-в-kerberos-согласно-rfc>#</a></h2><p>В начале имеются три участника протокола Kerberos:</p><ol><li>Клиент</li><li>Сервис</li><li>Центр распределения ключей</li></ol><p>Каждый из участников обладает своим долговременным секретом (ключом). Кроме того, центр распределения ключей обладает секретами всех участников.</p><p><figure><img src=images/gen_secrets.png alt=secrets_distribution><figcaption><p style=text-align:center>Рис. 3 - Первоначальное распределение секретов</p></figcaption></figure></p><h3 id=алгоритм-формирования-ключа>Алгоритм формирования ключа<a hidden class=anchor aria-hidden=true href=#алгоритм-формирования-ключа>#</a></h3><p>Ключ формируется как результат работы хэш-функции под названием string2key. Хэш может вычисляться разными способами в зависимости от соответствующих настроек Kerberos, в частности поддерживаются следующие алгоритмы:</p><table><thead><tr><th>Название алгоритма (etype)</th><th>Способ вычисления ключа</th></tr></thead><tbody><tr><td>RC4_HMAC_MD5</td><td>NT-хэш пароля участника</td></tr><tr><td>AES128_CTS_HMAC_SHA1_96</td><td>PBKDF2(пароль, соль*, kvno**, 128)</td></tr><tr><td>AES256_CTS_HMAC_SHA1_96</td><td>PBKDF2(пароль, соль*, kvno**, 256)</td></tr></tbody></table><p>В последних версиях Windows по умолчанию используется шифрование AES. Но для совместимости с системами ниже Windows Vista и Windows 2008 Server необходима поддержка алгоритма RC4.</p><p>Соль формируется следующим образом:</p><ul><li><p>Для доменных пользователей: полностью определенное имя домена заглавными буквами (FQDN) + регистр зависимое имя пользователя.</p><blockquote><p>Пример: <em>DOMAIN.LOCALuser</em></p></blockquote></li><li><p>Для компьютеров: <em>FQDN + host + регистр зависимое имя компьютера без $ в конце</em>.</p><blockquote><p>Пример: <em>DOMAIN.LOCALhostcomputer.domain.local</em></p></blockquote></li></ul><p><strong>kvno</strong> - key version number (в переводе - номер версии ключа). kvno представляет собой счетчик, увеличивающий значение каждый раз при смене пароля.</p><p>Таким образом, у одного и того же пользователя в разных доменах или для разных учетных записей будут разные секреты (хэши паролей), даже если пароль одинаковый. То есть строить радужные таблицы для указанных хэшей нецелесообразно.</p><p>Источники:</p><ul><li><a href=https://www.thehacker.recipes/ad/movement/kerberos>Kerberos from Hacker recipes</a></li><li><a href=https://snovvcrash.rocks/2021/05/21/calculating-kerberos-keys.html>A Note on Calculating Kerberos Keys for AD Accounts</a> (snovvcrash)</li></ul><h3 id=krb_as_req>KRB_AS_REQ<a hidden class=anchor aria-hidden=true href=#krb_as_req>#</a></h3><p><img src=images/KRB_AS_REQ_NO_PRE.png alt=KRB_AS_REQ_NO_PRE></p><p>Клиент отправляет серверу аутентификации запрос, содержащий:</p><ul><li>Принципал клиента</li><li>Срок жизни билета</li></ul><blockquote><p>Примечание: если это не первый материал по Kerberos, который вы читаете и возникает вопрос, почему отсутствует предварительная аутентификации, то поясню – это дополнительная настройка протокола, которая в «классической» реализации по умолчанию отключена. В реализации Kerberos для Active Directory, указанная настройка напротив по умолчанию активна и этот случай будет рассмотрен чуть <a href=#krb_as_req-%D1%81-%D0%BF%D1%80%D0%B5%D0%B4%D0%B2%D0%B0%D1%80%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B5%D0%B9>позже</a>.</p></blockquote><h3 id=krb_as_rep>KRB_AS_REP<a hidden class=anchor aria-hidden=true href=#krb_as_rep>#</a></h3><p><img src=images/KRB_AS_REP_NO_PRE.png alt=KRB_AS_REP></p><p>Сервер аутентификации по полученному принципалу находит в базе Kerberos секрет клиента. Кроме того, для дальнейшего общения с KDC сервер аутентификации случайным образом генерирует сессионный ключ. В итоге в ответ клиенту отправляются два сообщения.</p><p>Первое сообщение зашифровано с использованием секрета клиента и содержит:</p><ul><li>Сессионный ключ для KDC</li><li>Метка времени</li><li>Срок жизни TGT</li></ul><p>Второе сообщение (TGT) зашифровано уже с использованием (!) секрета KDC и включает в себя те же самые данные, что и первое сообщение, но вместе с принципалом клиента.</p><blockquote><p>Примечание: время жизни TGT определяется, как наименьшее время среди запрошенного клиентом и хранящегося в настройках центра распределения ключей.</p></blockquote><p>Клиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с KDC.
TGT также сохраняется у клиента в зашифрованном виде.</p><h3 id=krb_tgs_req>KRB_TGS_REQ<a hidden class=anchor aria-hidden=true href=#krb_tgs_req>#</a></h3><p><img src=images/TGS_REQ.png alt=KRB_TGS_REQ></p><p>Теперь, пройдя аутентификацию, клиент желает получить доступ к какому-то сервису. Для этого он отправляет серверу выдачи разрешений запрос, содержащий:</p><ul><li>Принципал сервиса</li><li>Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с KDC.</li><li>Сохраненный TGT</li></ul><p>Приняв запрос, сервер выдачи разрешений прежде всего выполняет проверку полученных данных. Сначала с использованием секрета KDC сервер расшифровывает TGT (1) и по метке времени со сроком действия убеждается, что TGT не протух (2).</p><p>Далее сервер извлекает сессионный ключ для KDC. Несмотря на то, что указанный ключ был создан в KDC, нужды хранить его в базе Kerberos нет. Действительно, TGT не может быть изменен кем-либо кроме KDC, поэтому полученным из него данным можно доверять.</p><p>Возникает важный вопрос - почему можно быть уверенным, что TGT не отправлен злоумышленником, перехватившим его при прослушивании сетевого трафика?
Для этого в запросе прилагается аутентификатор. Аутентификатор зашифрован с использованием сессионного ключа KDC, который мог быть извлечен из KRB_AS_REP запроса только определенным клиентом. Метка времени добавляется с целью предотвращения атак методом повтора, чтобы злоумышленник не смог вставить в свой запрос старый аутентификатор клиента, перехваченный из прошлых сообщений.</p><p>Сервер выдачи разрешений сравнивает принципалы пользователя из TGT и аутентификатора, а также убеждается, что аутентификатор был сформирован не более двух минут назад.</p><h3 id=krb_tgs_rep>KRB_TGS_REP<a hidden class=anchor aria-hidden=true href=#krb_tgs_rep>#</a></h3><p><img src=images/TGS_REP.png alt=KRB_TGS_REP></p><p>В случае успешного завершения проверок сервер выдачи разрешений отправляет клиенту ответ, содержащий два сообщения. Первое сообщение зашифровано с использованием сессионного ключа для KDC и содержит:</p><ul><li>Сессионный ключ для общения с сервисом</li><li>Метка времени</li><li>Срок жизни TGS билета</li><li>Принципал сервиса</li></ul><p>Второе сообщение (TGS билет) зашифровано с использованием секрета сервиса и включает в себя те же самые данные, что и первое сообщение, а также принципал клиента.</p><p>Клиент, приняв ответ, может расшифровать только первое сообщение. Таким образом он получает сессионный ключ для дальнейшего общения с сервисом.
TGS билет сохраняется у клиента в зашифрованном виде.</p><h3 id=krb_ap_req>KRB_AP_REQ<a hidden class=anchor aria-hidden=true href=#krb_ap_req>#</a></h3><p><img src=images/AP_REQ.png alt=KRB_AP_REQ></p><p>Клиент отправляет сервису запрос на получение доступа, содержащий:</p><ul><li>Аутентификатор, состоящий из принципала клиента и метки времени, зашифрованных с использованием извлеченного ранее сессионного ключа для общения с сервисом.</li><li>Сохраненный TGS билет</li><li>Флаг взаимной аутентификации</li></ul><p>Приняв запрос, сервис прежде всего выполняет проверку полученных данных. Сначала с использованием своего секрета сервис расшифровывает TGS (1) и по метке времени со сроком действия убеждается, что TGS не протух (2). Далее сервис извлекает сессионный ключ.</p><p>TGS билет не может быть изменен кем-либо кроме того, кто знает секрет сервиса, а это KDC и сам сервис. Сервис доверяет KDC, таким образом извлеченным из TGS билета данным сервис также может доверять.</p><p>Аналогично KRB_TGS_REQ расшифровывается аутентификатор и выполняются другие проверки.
Обратите внимание, что сервис удостоверяется в подлинности клиента, не обращаясь к KDC.</p><h3 id=krb_ap_rep>KRB_AP_REP<a hidden class=anchor aria-hidden=true href=#krb_ap_rep>#</a></h3><p><img src=images/AP_REP.png alt=KRB_AP_REP></p><p>Опционально, в случае если активен флаг взаимной аутентификации, сервис также подтверждает перед клиентом свою подлинность, отправив ответ с меткой времени, зашифрованной с использованием сессионного ключа.</p><h2 id=kerberos-в-active-directory>Kerberos в Active Directory<a hidden class=anchor aria-hidden=true href=#kerberos-в-active-directory>#</a></h2><p><em>«Чтобы донести идею её надо рассказать три раза, но разными словами»</em> <em>(с)</em></p><p>Рассмотрим реализацию Kerberos в Active Directory. Уточним терминологию, теперь:</p><p><strong>Область действия</strong> – домен.</p><p><strong>Центр распределения ключей</strong> – контроллер домена.</p><p><strong>Сервер аутентификации</strong> и <strong>сервер выдачи разрешений</strong> – оба объединены в рамках одного компонента, функционирующего на контроллере домена.</p><p><strong>База данных Kerberos</strong> – в Active Directory информация о секретах пользователей хранится на контроллерах домена в файле ntds.dit.</p><p><strong>krbtgt</strong> – название учетной записи, по умолчанию создаваемой вместе с доменом и обладающей секретом контроллера домена.</p><p>В итоге с учетом переименований получается следующая структура:</p><p><img src=images/ad_realm_high-AP.png alt=ad_realm></p><p>В целом в Active Directory Kerberos работает согласно RFC, но есть ряд особенностей. Рассмотрим указанные особенности на следующем примере.</p><h3 id=доменная-аутентификация-пользователя-к-рабочей-станции-в-active-directory>Доменная аутентификация пользователя к рабочей станции в Active Directory<a hidden class=anchor aria-hidden=true href=#доменная-аутентификация-пользователя-к-рабочей-станции-в-active-directory>#</a></h3><p>Изначально на рабочей станции активно следующее диалоговое окно:</p><p><img src=images/screen.png alt=logon_screen></p><p>Пользователь вводит свои учетные данные (название домена, имя учетной записи, пароль) и жмет «OK». Далее компонент, ответственный за отображение диалогового окна, передает запрос на аутентификацию пользователя с использованием введенных данных в локальный центр безопасности (<em>Local Security Authority, LSA</em>). Центр содержит различные динамические библиотеки, предоставляющие функции для процедур аутентификации, смены паролей, а также выдачи токенов. Указанные библиотеки вызываются и работают в контексте процесса lsass.exe (<em>Local Security Authority Subsystem Service</em>).</p><p>В зависимости от запроса для его обработки согласовывается соответствующая библиотека.
Примеры библиотек и протоколов:</p><ul><li>msv1_0.dll (NTLM)</li><li>kerberos.dll (Kerberos)</li><li>SChannel.dll (TLS/SSL)</li><li>WDigest.dll (digest аутентификация)</li></ul><p>По умолчанию для обработки запросов на проверку подлинности пользователя при входе в домен выбирается библиотека kerberos.dll, реализующая одноименный протокол.</p><p>Следует понимать, что пользователь никогда напрямую не взаимодействует с системой. Система олицетворяет пользователя и получает доступ к необходимым ресурсам с использованием прав доступа, которыми указанный пользователь обладает. Таким образом систему в ходе аутентификации можно рассматривать как сервис.</p><p>В итоге имеем следующую картину:</p><p><img src=images/KRB_Worstation_Start.png alt=KRB_Worstation_Start></p><p>Секрет системы (ключ) присваивается рабочей станции при ее добавлении в домен. Важно отметить, что введенный пользователем пароль не хранится в памяти рабочей станции. Ключ пользователя формируется при помощи ранее рассмотренной хэш-функции string2key.</p><p>Далее процесс, обеспечивающий аутентификацию пользователя, обращается к контроллеру домена с использованием сформированного ключа. Здесь проявляется одна из особенностей реализации Kerberos в Active Directory – предварительная аутентификация по умолчанию включена.</p><h3 id=krb_as_req-с-предварительной-аутентификацией>KRB_AS_REQ с предварительной аутентификацией<a hidden class=anchor aria-hidden=true href=#krb_as_req-с-предварительной-аутентификацией>#</a></h3><p><img src=images/KRB_AS_REP_AD.png alt=KRB_AS_REP_AD></p><p>В этом случае клиент отправляет серверу аутентификации запрос, содержащий:</p><ul><li>Принципал клиента</li><li>Метку времени, зашифрованную с использованием секрета клиента</li></ul><p>Получив запрос, контроллер домена с помощью секрета клиента расшифровывает метку времени и сравнивает её с текущим значением. Если переданное время расходится с текущим меньше чем на пять минут, то значит предварительная аутентификация клиента успешно пройдена. В противном случае контроллер отправляет сообщение об ошибке.</p><h3 id=krb_as_rep-ad>KRB_AS_REP (AD)<a hidden class=anchor aria-hidden=true href=#krb_as_rep-ad>#</a></h3><p>В случае успешного прохождения предварительной аутентификации контроллер домена отправляет рабочей станции ответ, аналогичный рассмотренному в разделе про RFC.</p><p><img src=images/KRB_ASREP_PAC.png alt=KRB_ASREP_PAC></p><p>В ответе появилась еще одна особенность, а именно новое поле «PAC» в содержимом TGT.</p><p>PAC (<em>Privilege Attribute Certificate</em>) это данные, предназначенные для авторизации пользователя. Ранее уже отмечалось, что кроме аутентификации Kerberos может использоваться при авторизации, но не пояснялось как. Поле PAC изначально было предусмотрено в RFC без конкретного описания содержимого. Какая информация передается в PAC и как она обрабатывается зависит от конкретной реализации Kerberos.</p><p>В Active Directory PAC среди прочего содержит следующую информацию:</p><ul><li>Идентификатор безопасности (SID) учетной записи пользователя</li><li>Идентификаторы групп, в которых состоит пользователь</li></ul><p>Указанная информация дважды подписывается. Одна подпись принадлежит krbtgt, а вторая сервису, к которому обращался клиент (в случае KRB_AS_REP тоже krbtgt).</p><h3 id=krb_tgs_req-ad>KRB_TGS_REQ (AD)<a hidden class=anchor aria-hidden=true href=#krb_tgs_req-ad>#</a></h3><p>Запрос производится аналогично рассмотренному ранее в RFC.</p><p><img src=images/Auth/AUTH_TGS_REQ.png alt=AUTH_TGS_REQ></p><h3 id=krb_tgs_rep-ad>KRB_TGS_REP (AD)<a hidden class=anchor aria-hidden=true href=#krb_tgs_rep-ad>#</a></h3><p>PAC из TGT, полученный в предыдущем сообщении, помещается в TGS билет. В этот раз PAC подписывается не только с использованием секрета krbtgt, но и секрета системы.</p><p><img src=images/Auth/AUTH_TGS_REP.png alt=AUTH_TGS_REP></p><h3 id=logon>LOGON<a hidden class=anchor aria-hidden=true href=#logon>#</a></h3><p>С использованием сессионного ключа LSA извлекает подписанный PAC из TGS билета. LSA проверяет подпись PAC при помощи секрета системы и далее с учетом добытых из PAC доменных групп безопасности формирует процесс Winlogon c соответствующим токеном доступа клиента.</p><p><img src=images/Auth/AUTH_Logon.png alt=AUTH_Logon></p><p>Опционально система может запросить контроллер домена выполнить дополнительную проверку подписи с PAC с помощью секрета krbtgt.</p><h2 id=итог>Итог<a hidden class=anchor aria-hidden=true href=#итог>#</a></h2><p>Думаю, для поверхностного знакомства с Kerberos достаточно. Несмотря на то, что многие моменты остались за скобками, представленного материала в целом хватает для понимания атак на протокол Kerberos, которые рассмотрим в следующей части.</p><h3 id=ссылки-на-используемые-источники>Ссылки на используемые источники<a hidden class=anchor aria-hidden=true href=#ссылки-на-используемые-источники>#</a></h3><ul><li><a href=https://www.kerberos.org/software/tutorial.html>Kerberos Protocol Tutorial</a> (Fulvio Ricciardi)</li><li><a href=https://medium.com/@robert.broeckelmann/kerberos-and-windows-security-series-59282e0f9465>Kerberos and Windows Security Series</a> (Robert Broeckelmann)</li><li>Статья с <a href=https://pro-ldap.ru/tr/zytrax/tech/kerberos.html>pro-ldap.ru</a></li><li><a href=https://en.hackndo.com/kerberos>Блог</a> Pixis</li><li>Фундаментальная <a href=https://www.tarlogic.com/blog/how-kerberos-works/>статья</a> c tarlogic.com (Eloy Pérez)</li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)?redirectedfrom=MSDN">Документация Microsoft</a></li><li><a href=https://sheerazali.com/how-to-kerberos-its-components-and-function/>How to Kerberos? its components and function</a> (Sheeraz Ali)</li><li><a href=https://blog.redforce.io/windows-authentication-attacks-part-2-kerberos/>Windows authentication attacks part 2 – kerberos</a> (Ahmed Sultan)</li></ul><p>Картинка для обложки взята <a href=https://pikabu.ru/story/malyish_tserber_5496474>отсюда</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ardent101.github.io/tags/active-directory/>Active Directory</a></li><li><a href=https://ardent101.github.io/tags/kerberos/>Kerberos</a></li><li><a href=https://ardent101.github.io/tags/pentest/>Pentest</a></li><li><a href=https://ardent101.github.io/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F/>Теория</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on twitter" href="https://twitter.com/intent/tweet/?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f&url=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f&hashtags=ActiveDirectory%2cKerberos%2cPentest%2c%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f&title=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f&summary=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f&source=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f&title=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on whatsapp" href="https://api.whatsapp.com/send?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f%20-%20https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Kerberos для специалиста по тестированию на проникновение. Часть 1. Теория on telegram" href="https://telegram.me/share/url?text=Kerberos%20%d0%b4%d0%bb%d1%8f%20%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d1%81%d1%82%d0%b0%20%d0%bf%d0%be%20%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e%20%d0%bd%d0%b0%20%d0%bf%d1%80%d0%be%d0%bd%d0%b8%d0%ba%d0%bd%d0%be%d0%b2%d0%b5%d0%bd%d0%b8%d0%b5.%20%d0%a7%d0%b0%d1%81%d1%82%d1%8c%201.%20%d0%a2%d0%b5%d0%be%d1%80%d0%b8%d1%8f&url=https%3a%2f%2fardent101.github.io%2fposts%2fkerberos_theory%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ardent101.github.io/>Ardent101</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="копировать";function s(){e.innerText="скопировано!",setTimeout(()=>{e.innerText="копировать"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>